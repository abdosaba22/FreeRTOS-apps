
FreeRTOS_APP1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001072  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000030  00800060  00001072  00001106  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000047f  00800090  00800090  00001136  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001136  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001168  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002a0  00000000  00000000  000011a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003034  00000000  00000000  00001444  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000e1b  00000000  00000000  00004478  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001e1c  00000000  00000000  00005293  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000007f8  00000000  00000000  000070b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000103e  00000000  00000000  000078a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000029c6  00000000  00000000  000088e6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000260  00000000  00000000  0000b2ac  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 8b 04 	jmp	0x916	; 0x916 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e7       	ldi	r30, 0x72	; 114
      68:	f0 e1       	ldi	r31, 0x10	; 16
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a0 39       	cpi	r26, 0x90	; 144
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	25 e0       	ldi	r18, 0x05	; 5
      78:	a0 e9       	ldi	r26, 0x90	; 144
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 30       	cpi	r26, 0x0F	; 15
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 57 03 	call	0x6ae	; 0x6ae <main>
      8a:	0c 94 37 08 	jmp	0x106e	; 0x106e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <prvHeapInit>:
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
      92:	e5 e9       	ldi	r30, 0x95	; 149
      94:	f0 e0       	ldi	r31, 0x00	; 0
      96:	8a e9       	ldi	r24, 0x9A	; 154
      98:	90 e0       	ldi	r25, 0x00	; 0
      9a:	91 83       	std	Z+1, r25	; 0x01
      9c:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
      9e:	13 82       	std	Z+3, r1	; 0x03
      a0:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
      a2:	e1 e9       	ldi	r30, 0x91	; 145
      a4:	f0 e0       	ldi	r31, 0x00	; 0
      a6:	87 ee       	ldi	r24, 0xE7	; 231
      a8:	93 e0       	ldi	r25, 0x03	; 3
      aa:	93 83       	std	Z+3, r25	; 0x03
      ac:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
      ae:	11 82       	std	Z+1, r1	; 0x01
      b0:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
      b2:	a9 e9       	ldi	r26, 0x99	; 153
      b4:	b0 e0       	ldi	r27, 0x00	; 0
      b6:	14 96       	adiw	r26, 0x04	; 4
      b8:	9c 93       	st	X, r25
      ba:	8e 93       	st	-X, r24
      bc:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
      be:	12 96       	adiw	r26, 0x02	; 2
      c0:	fc 93       	st	X, r31
      c2:	ee 93       	st	-X, r30
      c4:	11 97       	sbiw	r26, 0x01	; 1
      c6:	08 95       	ret

000000c8 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      c8:	0f 93       	push	r16
      ca:	1f 93       	push	r17
      cc:	cf 93       	push	r28
      ce:	df 93       	push	r29
      d0:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
      d2:	0e 94 91 06 	call	0xd22	; 0xd22 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
      d6:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <__data_end>
      da:	81 11       	cpse	r24, r1
      dc:	05 c0       	rjmp	.+10     	; 0xe8 <pvPortMalloc+0x20>
		{
			prvHeapInit();
      de:	0e 94 49 00 	call	0x92	; 0x92 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
      e2:	81 e0       	ldi	r24, 0x01	; 1
      e4:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
      e8:	20 97       	sbiw	r28, 0x00	; 0
      ea:	09 f0       	breq	.+2      	; 0xee <pvPortMalloc+0x26>
		{
			xWantedSize += heapSTRUCT_SIZE;
      ec:	24 96       	adiw	r28, 0x04	; 4
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
      ee:	ce 01       	movw	r24, r28
      f0:	01 97       	sbiw	r24, 0x01	; 1
      f2:	86 3e       	cpi	r24, 0xE6	; 230
      f4:	93 40       	sbci	r25, 0x03	; 3
      f6:	08 f0       	brcs	.+2      	; 0xfa <pvPortMalloc+0x32>
      f8:	56 c0       	rjmp	.+172    	; 0x1a6 <pvPortMalloc+0xde>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
      fa:	e0 91 95 00 	lds	r30, 0x0095	; 0x800095 <xStart>
      fe:	f0 91 96 00 	lds	r31, 0x0096	; 0x800096 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     102:	a5 e9       	ldi	r26, 0x95	; 149
     104:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     106:	02 c0       	rjmp	.+4      	; 0x10c <pvPortMalloc+0x44>
			{
				pxPreviousBlock = pxBlock;
     108:	df 01       	movw	r26, r30
				pxBlock = pxBlock->pxNextFreeBlock;
     10a:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     10c:	82 81       	ldd	r24, Z+2	; 0x02
     10e:	93 81       	ldd	r25, Z+3	; 0x03
     110:	8c 17       	cp	r24, r28
     112:	9d 07       	cpc	r25, r29
     114:	20 f4       	brcc	.+8      	; 0x11e <pvPortMalloc+0x56>
     116:	80 81       	ld	r24, Z
     118:	91 81       	ldd	r25, Z+1	; 0x01
     11a:	00 97       	sbiw	r24, 0x00	; 0
     11c:	a9 f7       	brne	.-22     	; 0x108 <pvPortMalloc+0x40>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     11e:	80 e0       	ldi	r24, 0x00	; 0
     120:	e1 39       	cpi	r30, 0x91	; 145
     122:	f8 07       	cpc	r31, r24
     124:	09 f4       	brne	.+2      	; 0x128 <pvPortMalloc+0x60>
     126:	42 c0       	rjmp	.+132    	; 0x1ac <pvPortMalloc+0xe4>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     128:	0d 91       	ld	r16, X+
     12a:	1c 91       	ld	r17, X
     12c:	11 97       	sbiw	r26, 0x01	; 1
     12e:	0c 5f       	subi	r16, 0xFC	; 252
     130:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     132:	80 81       	ld	r24, Z
     134:	91 81       	ldd	r25, Z+1	; 0x01
     136:	8d 93       	st	X+, r24
     138:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     13a:	82 81       	ldd	r24, Z+2	; 0x02
     13c:	93 81       	ldd	r25, Z+3	; 0x03
     13e:	8c 1b       	sub	r24, r28
     140:	9d 0b       	sbc	r25, r29
     142:	89 30       	cpi	r24, 0x09	; 9
     144:	91 05       	cpc	r25, r1
     146:	10 f1       	brcs	.+68     	; 0x18c <pvPortMalloc+0xc4>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     148:	af 01       	movw	r20, r30
     14a:	4c 0f       	add	r20, r28
     14c:	5d 1f       	adc	r21, r29

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     14e:	da 01       	movw	r26, r20
     150:	13 96       	adiw	r26, 0x03	; 3
     152:	9c 93       	st	X, r25
     154:	8e 93       	st	-X, r24
     156:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     158:	d3 83       	std	Z+3, r29	; 0x03
     15a:	c2 83       	std	Z+2, r28	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     15c:	12 96       	adiw	r26, 0x02	; 2
     15e:	2d 91       	ld	r18, X+
     160:	3c 91       	ld	r19, X
     162:	13 97       	sbiw	r26, 0x03	; 3
     164:	65 e9       	ldi	r22, 0x95	; 149
     166:	70 e0       	ldi	r23, 0x00	; 0
     168:	01 c0       	rjmp	.+2      	; 0x16c <pvPortMalloc+0xa4>
     16a:	bd 01       	movw	r22, r26
     16c:	eb 01       	movw	r28, r22
     16e:	a8 81       	ld	r26, Y
     170:	b9 81       	ldd	r27, Y+1	; 0x01
     172:	12 96       	adiw	r26, 0x02	; 2
     174:	8d 91       	ld	r24, X+
     176:	9c 91       	ld	r25, X
     178:	13 97       	sbiw	r26, 0x03	; 3
     17a:	82 17       	cp	r24, r18
     17c:	93 07       	cpc	r25, r19
     17e:	a8 f3       	brcs	.-22     	; 0x16a <pvPortMalloc+0xa2>
     180:	ea 01       	movw	r28, r20
     182:	b9 83       	std	Y+1, r27	; 0x01
     184:	a8 83       	st	Y, r26
     186:	db 01       	movw	r26, r22
     188:	4d 93       	st	X+, r20
     18a:	5c 93       	st	X, r21
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     18c:	22 81       	ldd	r18, Z+2	; 0x02
     18e:	33 81       	ldd	r19, Z+3	; 0x03
     190:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     194:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     198:	82 1b       	sub	r24, r18
     19a:	93 0b       	sbc	r25, r19
     19c:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     1a0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     1a4:	05 c0       	rjmp	.+10     	; 0x1b0 <pvPortMalloc+0xe8>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     1a6:	00 e0       	ldi	r16, 0x00	; 0
     1a8:	10 e0       	ldi	r17, 0x00	; 0
     1aa:	02 c0       	rjmp	.+4      	; 0x1b0 <pvPortMalloc+0xe8>
     1ac:	00 e0       	ldi	r16, 0x00	; 0
     1ae:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     1b0:	0e 94 21 07 	call	0xe42	; 0xe42 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     1b4:	c8 01       	movw	r24, r16
     1b6:	df 91       	pop	r29
     1b8:	cf 91       	pop	r28
     1ba:	1f 91       	pop	r17
     1bc:	0f 91       	pop	r16
     1be:	08 95       	ret

000001c0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     1c0:	0f 93       	push	r16
     1c2:	1f 93       	push	r17
     1c4:	cf 93       	push	r28
     1c6:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     1c8:	00 97       	sbiw	r24, 0x00	; 0
     1ca:	41 f1       	breq	.+80     	; 0x21c <vPortFree+0x5c>
     1cc:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     1ce:	8c 01       	movw	r16, r24
     1d0:	04 50       	subi	r16, 0x04	; 4
     1d2:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     1d4:	0e 94 91 06 	call	0xd22	; 0xd22 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     1d8:	f8 01       	movw	r30, r16
     1da:	42 81       	ldd	r20, Z+2	; 0x02
     1dc:	53 81       	ldd	r21, Z+3	; 0x03
     1de:	a5 e9       	ldi	r26, 0x95	; 149
     1e0:	b0 e0       	ldi	r27, 0x00	; 0
     1e2:	01 c0       	rjmp	.+2      	; 0x1e6 <vPortFree+0x26>
     1e4:	df 01       	movw	r26, r30
     1e6:	ed 91       	ld	r30, X+
     1e8:	fc 91       	ld	r31, X
     1ea:	11 97       	sbiw	r26, 0x01	; 1
     1ec:	22 81       	ldd	r18, Z+2	; 0x02
     1ee:	33 81       	ldd	r19, Z+3	; 0x03
     1f0:	24 17       	cp	r18, r20
     1f2:	35 07       	cpc	r19, r21
     1f4:	b8 f3       	brcs	.-18     	; 0x1e4 <vPortFree+0x24>
     1f6:	24 97       	sbiw	r28, 0x04	; 4
     1f8:	f9 83       	std	Y+1, r31	; 0x01
     1fa:	e8 83       	st	Y, r30
     1fc:	0d 93       	st	X+, r16
     1fe:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     200:	8a 81       	ldd	r24, Y+2	; 0x02
     202:	9b 81       	ldd	r25, Y+3	; 0x03
     204:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     208:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     20c:	82 0f       	add	r24, r18
     20e:	93 1f       	adc	r25, r19
     210:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     214:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     218:	0e 94 21 07 	call	0xe42	; 0xe42 <xTaskResumeAll>
	}
}
     21c:	df 91       	pop	r29
     21e:	cf 91       	pop	r28
     220:	1f 91       	pop	r17
     222:	0f 91       	pop	r16
     224:	08 95       	ret

00000226 <LCD_write_command>:
*****************************************************************************/

void LCD_write_command(uint8_t com){
	
	// send last 4 bits in com after enable command
	RS(0);
     226:	9b b3       	in	r25, 0x1b	; 27
     228:	9b 7f       	andi	r25, 0xFB	; 251
     22a:	9b bb       	out	0x1b, r25	; 27
	D4(READBIT(com,4));
     22c:	84 ff       	sbrs	r24, 4
     22e:	04 c0       	rjmp	.+8      	; 0x238 <LCD_write_command+0x12>
     230:	9b b3       	in	r25, 0x1b	; 27
     232:	90 61       	ori	r25, 0x10	; 16
     234:	9b bb       	out	0x1b, r25	; 27
     236:	03 c0       	rjmp	.+6      	; 0x23e <LCD_write_command+0x18>
     238:	9b b3       	in	r25, 0x1b	; 27
     23a:	9f 7e       	andi	r25, 0xEF	; 239
     23c:	9b bb       	out	0x1b, r25	; 27
	D5(READBIT(com,5));
     23e:	85 ff       	sbrs	r24, 5
     240:	04 c0       	rjmp	.+8      	; 0x24a <LCD_write_command+0x24>
     242:	9b b3       	in	r25, 0x1b	; 27
     244:	90 62       	ori	r25, 0x20	; 32
     246:	9b bb       	out	0x1b, r25	; 27
     248:	03 c0       	rjmp	.+6      	; 0x250 <LCD_write_command+0x2a>
     24a:	9b b3       	in	r25, 0x1b	; 27
     24c:	9f 7d       	andi	r25, 0xDF	; 223
     24e:	9b bb       	out	0x1b, r25	; 27
	D6(READBIT(com,6));
     250:	86 ff       	sbrs	r24, 6
     252:	04 c0       	rjmp	.+8      	; 0x25c <LCD_write_command+0x36>
     254:	9b b3       	in	r25, 0x1b	; 27
     256:	90 64       	ori	r25, 0x40	; 64
     258:	9b bb       	out	0x1b, r25	; 27
     25a:	03 c0       	rjmp	.+6      	; 0x262 <LCD_write_command+0x3c>
     25c:	9b b3       	in	r25, 0x1b	; 27
     25e:	9f 7b       	andi	r25, 0xBF	; 191
     260:	9b bb       	out	0x1b, r25	; 27
	D7(READBIT(com,7));
     262:	88 23       	and	r24, r24
     264:	24 f4       	brge	.+8      	; 0x26e <LCD_write_command+0x48>
     266:	9b b3       	in	r25, 0x1b	; 27
     268:	90 68       	ori	r25, 0x80	; 128
     26a:	9b bb       	out	0x1b, r25	; 27
     26c:	03 c0       	rjmp	.+6      	; 0x274 <LCD_write_command+0x4e>
     26e:	9b b3       	in	r25, 0x1b	; 27
     270:	9f 77       	andi	r25, 0x7F	; 127
     272:	9b bb       	out	0x1b, r25	; 27
	EN(1);
     274:	9b b3       	in	r25, 0x1b	; 27
     276:	98 60       	ori	r25, 0x08	; 8
     278:	9b bb       	out	0x1b, r25	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     27a:	ef e9       	ldi	r30, 0x9F	; 159
     27c:	ff e0       	ldi	r31, 0x0F	; 15
     27e:	31 97       	sbiw	r30, 0x01	; 1
     280:	f1 f7       	brne	.-4      	; 0x27e <LCD_write_command+0x58>
     282:	00 c0       	rjmp	.+0      	; 0x284 <LCD_write_command+0x5e>
     284:	00 00       	nop
	_delay_ms(1);
	EN(0);
     286:	9b b3       	in	r25, 0x1b	; 27
     288:	97 7f       	andi	r25, 0xF7	; 247
     28a:	9b bb       	out	0x1b, r25	; 27
     28c:	ef e9       	ldi	r30, 0x9F	; 159
     28e:	ff e0       	ldi	r31, 0x0F	; 15
     290:	31 97       	sbiw	r30, 0x01	; 1
     292:	f1 f7       	brne	.-4      	; 0x290 <LCD_write_command+0x6a>
     294:	00 c0       	rjmp	.+0      	; 0x296 <LCD_write_command+0x70>
     296:	00 00       	nop
	_delay_ms(1);
	
	// send first 4 bits in com after enable command 
	D4(READBIT(com,0));
     298:	80 ff       	sbrs	r24, 0
     29a:	04 c0       	rjmp	.+8      	; 0x2a4 <LCD_write_command+0x7e>
     29c:	9b b3       	in	r25, 0x1b	; 27
     29e:	90 61       	ori	r25, 0x10	; 16
     2a0:	9b bb       	out	0x1b, r25	; 27
     2a2:	03 c0       	rjmp	.+6      	; 0x2aa <LCD_write_command+0x84>
     2a4:	9b b3       	in	r25, 0x1b	; 27
     2a6:	9f 7e       	andi	r25, 0xEF	; 239
     2a8:	9b bb       	out	0x1b, r25	; 27
	D5(READBIT(com,1));
     2aa:	81 ff       	sbrs	r24, 1
     2ac:	04 c0       	rjmp	.+8      	; 0x2b6 <LCD_write_command+0x90>
     2ae:	9b b3       	in	r25, 0x1b	; 27
     2b0:	90 62       	ori	r25, 0x20	; 32
     2b2:	9b bb       	out	0x1b, r25	; 27
     2b4:	03 c0       	rjmp	.+6      	; 0x2bc <LCD_write_command+0x96>
     2b6:	9b b3       	in	r25, 0x1b	; 27
     2b8:	9f 7d       	andi	r25, 0xDF	; 223
     2ba:	9b bb       	out	0x1b, r25	; 27
	D6(READBIT(com,2));
     2bc:	82 ff       	sbrs	r24, 2
     2be:	04 c0       	rjmp	.+8      	; 0x2c8 <LCD_write_command+0xa2>
     2c0:	9b b3       	in	r25, 0x1b	; 27
     2c2:	90 64       	ori	r25, 0x40	; 64
     2c4:	9b bb       	out	0x1b, r25	; 27
     2c6:	03 c0       	rjmp	.+6      	; 0x2ce <LCD_write_command+0xa8>
     2c8:	9b b3       	in	r25, 0x1b	; 27
     2ca:	9f 7b       	andi	r25, 0xBF	; 191
     2cc:	9b bb       	out	0x1b, r25	; 27
	D7(READBIT(com,3));
     2ce:	83 ff       	sbrs	r24, 3
     2d0:	04 c0       	rjmp	.+8      	; 0x2da <LCD_write_command+0xb4>
     2d2:	8b b3       	in	r24, 0x1b	; 27
     2d4:	80 68       	ori	r24, 0x80	; 128
     2d6:	8b bb       	out	0x1b, r24	; 27
     2d8:	03 c0       	rjmp	.+6      	; 0x2e0 <LCD_write_command+0xba>
     2da:	8b b3       	in	r24, 0x1b	; 27
     2dc:	8f 77       	andi	r24, 0x7F	; 127
     2de:	8b bb       	out	0x1b, r24	; 27
	EN(1);
     2e0:	8b b3       	in	r24, 0x1b	; 27
     2e2:	88 60       	ori	r24, 0x08	; 8
     2e4:	8b bb       	out	0x1b, r24	; 27
     2e6:	8f e9       	ldi	r24, 0x9F	; 159
     2e8:	9f e0       	ldi	r25, 0x0F	; 15
     2ea:	01 97       	sbiw	r24, 0x01	; 1
     2ec:	f1 f7       	brne	.-4      	; 0x2ea <LCD_write_command+0xc4>
     2ee:	00 c0       	rjmp	.+0      	; 0x2f0 <LCD_write_command+0xca>
     2f0:	00 00       	nop
	_delay_ms(1);
	EN(0);	
     2f2:	8b b3       	in	r24, 0x1b	; 27
     2f4:	87 7f       	andi	r24, 0xF7	; 247
     2f6:	8b bb       	out	0x1b, r24	; 27
     2f8:	ef e9       	ldi	r30, 0x9F	; 159
     2fa:	ff e0       	ldi	r31, 0x0F	; 15
     2fc:	31 97       	sbiw	r30, 0x01	; 1
     2fe:	f1 f7       	brne	.-4      	; 0x2fc <LCD_write_command+0xd6>
     300:	00 c0       	rjmp	.+0      	; 0x302 <LCD_write_command+0xdc>
     302:	00 00       	nop
     304:	08 95       	ret

00000306 <LCD_init>:
* Purpose      : initialize LCD - enable mode 4-bit mode - enable both lines - cursor off
* Parameters   : void
* Return value : void
*****************************************************************************/
void LCD_init(void){
	LCD_PORT_INIT();
     306:	8a b3       	in	r24, 0x1a	; 26
     308:	8c 6f       	ori	r24, 0xFC	; 252
     30a:	8a bb       	out	0x1a, r24	; 26
	LCD_write_command(0x3);
     30c:	83 e0       	ldi	r24, 0x03	; 3
     30e:	0e 94 13 01 	call	0x226	; 0x226 <LCD_write_command>
     312:	8f e7       	ldi	r24, 0x7F	; 127
     314:	9e e3       	ldi	r25, 0x3E	; 62
     316:	01 97       	sbiw	r24, 0x01	; 1
     318:	f1 f7       	brne	.-4      	; 0x316 <LCD_init+0x10>
     31a:	00 c0       	rjmp	.+0      	; 0x31c <LCD_init+0x16>
     31c:	00 00       	nop
	_delay_ms(4);
	LCD_write_command(0x3);
     31e:	83 e0       	ldi	r24, 0x03	; 3
     320:	0e 94 13 01 	call	0x226	; 0x226 <LCD_write_command>
     324:	8f e7       	ldi	r24, 0x7F	; 127
     326:	9e e3       	ldi	r25, 0x3E	; 62
     328:	01 97       	sbiw	r24, 0x01	; 1
     32a:	f1 f7       	brne	.-4      	; 0x328 <LCD_init+0x22>
     32c:	00 c0       	rjmp	.+0      	; 0x32e <LCD_init+0x28>
     32e:	00 00       	nop
	_delay_ms(4);
	LCD_write_command(0x3);
     330:	83 e0       	ldi	r24, 0x03	; 3
     332:	0e 94 13 01 	call	0x226	; 0x226 <LCD_write_command>
     336:	8f e7       	ldi	r24, 0x7F	; 127
     338:	9e e3       	ldi	r25, 0x3E	; 62
     33a:	01 97       	sbiw	r24, 0x01	; 1
     33c:	f1 f7       	brne	.-4      	; 0x33a <LCD_init+0x34>
     33e:	00 c0       	rjmp	.+0      	; 0x340 <LCD_init+0x3a>
     340:	00 00       	nop
	_delay_ms(4);
	LCD_write_command(0x2); //enable 4-bit mode 
     342:	82 e0       	ldi	r24, 0x02	; 2
     344:	0e 94 13 01 	call	0x226	; 0x226 <LCD_write_command>
	LCD_write_command(0x28);
     348:	88 e2       	ldi	r24, 0x28	; 40
     34a:	0e 94 13 01 	call	0x226	; 0x226 <LCD_write_command>
	LCD_write_command(0x08);
     34e:	88 e0       	ldi	r24, 0x08	; 8
     350:	0e 94 13 01 	call	0x226	; 0x226 <LCD_write_command>
	LCD_write_command(0x01);//to clear LCD 
     354:	81 e0       	ldi	r24, 0x01	; 1
     356:	0e 94 13 01 	call	0x226	; 0x226 <LCD_write_command>
	LCD_write_command(0x06);//make cursor increment to right 
     35a:	86 e0       	ldi	r24, 0x06	; 6
     35c:	0e 94 13 01 	call	0x226	; 0x226 <LCD_write_command>
	LCD_write_command(0x0C);//turn on the display
     360:	8c e0       	ldi	r24, 0x0C	; 12
     362:	0e 94 13 01 	call	0x226	; 0x226 <LCD_write_command>
     366:	9f ef       	ldi	r25, 0xFF	; 255
     368:	29 ef       	ldi	r18, 0xF9	; 249
     36a:	80 e0       	ldi	r24, 0x00	; 0
     36c:	91 50       	subi	r25, 0x01	; 1
     36e:	20 40       	sbci	r18, 0x00	; 0
     370:	80 40       	sbci	r24, 0x00	; 0
     372:	e1 f7       	brne	.-8      	; 0x36c <LCD_init+0x66>
     374:	00 c0       	rjmp	.+0      	; 0x376 <LCD_init+0x70>
     376:	00 00       	nop
     378:	08 95       	ret

0000037a <LCD_write_char>:
* Return value : void
*****************************************************************************/

void LCD_write_char(uint8_t data){
	// send last 4 bits in com after enable command
	RS(1);
     37a:	9b b3       	in	r25, 0x1b	; 27
     37c:	94 60       	ori	r25, 0x04	; 4
     37e:	9b bb       	out	0x1b, r25	; 27
	D4(READBIT(data,4));
     380:	84 ff       	sbrs	r24, 4
     382:	04 c0       	rjmp	.+8      	; 0x38c <LCD_write_char+0x12>
     384:	9b b3       	in	r25, 0x1b	; 27
     386:	90 61       	ori	r25, 0x10	; 16
     388:	9b bb       	out	0x1b, r25	; 27
     38a:	03 c0       	rjmp	.+6      	; 0x392 <LCD_write_char+0x18>
     38c:	9b b3       	in	r25, 0x1b	; 27
     38e:	9f 7e       	andi	r25, 0xEF	; 239
     390:	9b bb       	out	0x1b, r25	; 27
	D5(READBIT(data,5));
     392:	85 ff       	sbrs	r24, 5
     394:	04 c0       	rjmp	.+8      	; 0x39e <LCD_write_char+0x24>
     396:	9b b3       	in	r25, 0x1b	; 27
     398:	90 62       	ori	r25, 0x20	; 32
     39a:	9b bb       	out	0x1b, r25	; 27
     39c:	03 c0       	rjmp	.+6      	; 0x3a4 <LCD_write_char+0x2a>
     39e:	9b b3       	in	r25, 0x1b	; 27
     3a0:	9f 7d       	andi	r25, 0xDF	; 223
     3a2:	9b bb       	out	0x1b, r25	; 27
	D6(READBIT(data,6));
     3a4:	86 ff       	sbrs	r24, 6
     3a6:	04 c0       	rjmp	.+8      	; 0x3b0 <LCD_write_char+0x36>
     3a8:	9b b3       	in	r25, 0x1b	; 27
     3aa:	90 64       	ori	r25, 0x40	; 64
     3ac:	9b bb       	out	0x1b, r25	; 27
     3ae:	03 c0       	rjmp	.+6      	; 0x3b6 <LCD_write_char+0x3c>
     3b0:	9b b3       	in	r25, 0x1b	; 27
     3b2:	9f 7b       	andi	r25, 0xBF	; 191
     3b4:	9b bb       	out	0x1b, r25	; 27
	D7(READBIT(data,7));
     3b6:	88 23       	and	r24, r24
     3b8:	24 f4       	brge	.+8      	; 0x3c2 <LCD_write_char+0x48>
     3ba:	9b b3       	in	r25, 0x1b	; 27
     3bc:	90 68       	ori	r25, 0x80	; 128
     3be:	9b bb       	out	0x1b, r25	; 27
     3c0:	03 c0       	rjmp	.+6      	; 0x3c8 <LCD_write_char+0x4e>
     3c2:	9b b3       	in	r25, 0x1b	; 27
     3c4:	9f 77       	andi	r25, 0x7F	; 127
     3c6:	9b bb       	out	0x1b, r25	; 27
	EN(1);
     3c8:	9b b3       	in	r25, 0x1b	; 27
     3ca:	98 60       	ori	r25, 0x08	; 8
     3cc:	9b bb       	out	0x1b, r25	; 27
     3ce:	ef e9       	ldi	r30, 0x9F	; 159
     3d0:	ff e0       	ldi	r31, 0x0F	; 15
     3d2:	31 97       	sbiw	r30, 0x01	; 1
     3d4:	f1 f7       	brne	.-4      	; 0x3d2 <LCD_write_char+0x58>
     3d6:	00 c0       	rjmp	.+0      	; 0x3d8 <LCD_write_char+0x5e>
     3d8:	00 00       	nop
	_delay_ms(1);
	EN(0);
     3da:	9b b3       	in	r25, 0x1b	; 27
     3dc:	97 7f       	andi	r25, 0xF7	; 247
     3de:	9b bb       	out	0x1b, r25	; 27
     3e0:	ef e9       	ldi	r30, 0x9F	; 159
     3e2:	ff e0       	ldi	r31, 0x0F	; 15
     3e4:	31 97       	sbiw	r30, 0x01	; 1
     3e6:	f1 f7       	brne	.-4      	; 0x3e4 <LCD_write_char+0x6a>
     3e8:	00 c0       	rjmp	.+0      	; 0x3ea <LCD_write_char+0x70>
     3ea:	00 00       	nop
	_delay_ms(1);
	
	// send first 4 bits in com after enable command
	D4(READBIT(data,0));
     3ec:	80 ff       	sbrs	r24, 0
     3ee:	04 c0       	rjmp	.+8      	; 0x3f8 <LCD_write_char+0x7e>
     3f0:	9b b3       	in	r25, 0x1b	; 27
     3f2:	90 61       	ori	r25, 0x10	; 16
     3f4:	9b bb       	out	0x1b, r25	; 27
     3f6:	03 c0       	rjmp	.+6      	; 0x3fe <LCD_write_char+0x84>
     3f8:	9b b3       	in	r25, 0x1b	; 27
     3fa:	9f 7e       	andi	r25, 0xEF	; 239
     3fc:	9b bb       	out	0x1b, r25	; 27
	D5(READBIT(data,1));
     3fe:	81 ff       	sbrs	r24, 1
     400:	04 c0       	rjmp	.+8      	; 0x40a <__EEPROM_REGION_LENGTH__+0xa>
     402:	9b b3       	in	r25, 0x1b	; 27
     404:	90 62       	ori	r25, 0x20	; 32
     406:	9b bb       	out	0x1b, r25	; 27
     408:	03 c0       	rjmp	.+6      	; 0x410 <__EEPROM_REGION_LENGTH__+0x10>
     40a:	9b b3       	in	r25, 0x1b	; 27
     40c:	9f 7d       	andi	r25, 0xDF	; 223
     40e:	9b bb       	out	0x1b, r25	; 27
	D6(READBIT(data,2));
     410:	82 ff       	sbrs	r24, 2
     412:	04 c0       	rjmp	.+8      	; 0x41c <__EEPROM_REGION_LENGTH__+0x1c>
     414:	9b b3       	in	r25, 0x1b	; 27
     416:	90 64       	ori	r25, 0x40	; 64
     418:	9b bb       	out	0x1b, r25	; 27
     41a:	03 c0       	rjmp	.+6      	; 0x422 <__EEPROM_REGION_LENGTH__+0x22>
     41c:	9b b3       	in	r25, 0x1b	; 27
     41e:	9f 7b       	andi	r25, 0xBF	; 191
     420:	9b bb       	out	0x1b, r25	; 27
	D7(READBIT(data,3));
     422:	83 ff       	sbrs	r24, 3
     424:	04 c0       	rjmp	.+8      	; 0x42e <__EEPROM_REGION_LENGTH__+0x2e>
     426:	8b b3       	in	r24, 0x1b	; 27
     428:	80 68       	ori	r24, 0x80	; 128
     42a:	8b bb       	out	0x1b, r24	; 27
     42c:	03 c0       	rjmp	.+6      	; 0x434 <__EEPROM_REGION_LENGTH__+0x34>
     42e:	8b b3       	in	r24, 0x1b	; 27
     430:	8f 77       	andi	r24, 0x7F	; 127
     432:	8b bb       	out	0x1b, r24	; 27
	EN(1);
     434:	8b b3       	in	r24, 0x1b	; 27
     436:	88 60       	ori	r24, 0x08	; 8
     438:	8b bb       	out	0x1b, r24	; 27
     43a:	8f e9       	ldi	r24, 0x9F	; 159
     43c:	9f e0       	ldi	r25, 0x0F	; 15
     43e:	01 97       	sbiw	r24, 0x01	; 1
     440:	f1 f7       	brne	.-4      	; 0x43e <__EEPROM_REGION_LENGTH__+0x3e>
     442:	00 c0       	rjmp	.+0      	; 0x444 <__EEPROM_REGION_LENGTH__+0x44>
     444:	00 00       	nop
	_delay_ms(1);
	EN(0);
     446:	8b b3       	in	r24, 0x1b	; 27
     448:	87 7f       	andi	r24, 0xF7	; 247
     44a:	8b bb       	out	0x1b, r24	; 27
     44c:	ef e9       	ldi	r30, 0x9F	; 159
     44e:	ff e0       	ldi	r31, 0x0F	; 15
     450:	31 97       	sbiw	r30, 0x01	; 1
     452:	f1 f7       	brne	.-4      	; 0x450 <__EEPROM_REGION_LENGTH__+0x50>
     454:	00 c0       	rjmp	.+0      	; 0x456 <__EEPROM_REGION_LENGTH__+0x56>
     456:	00 00       	nop
     458:	08 95       	ret

0000045a <LCD_write_num>:
* Purpose      : display a specific number on LCD
* Parameters   : uint16_t: 5 digit number or less
* Return value : void
*************************************************************************/

void LCD_write_num(uint16_t num){
     45a:	1f 93       	push	r17
     45c:	cf 93       	push	r28
     45e:	df 93       	push	r29
     460:	00 d0       	rcall	.+0      	; 0x462 <LCD_write_num+0x8>
     462:	00 d0       	rcall	.+0      	; 0x464 <LCD_write_num+0xa>
     464:	1f 92       	push	r1
     466:	cd b7       	in	r28, 0x3d	; 61
     468:	de b7       	in	r29, 0x3e	; 62
     46a:	ac 01       	movw	r20, r24
	if (num ==0) {LCD_write_char(num+ '0');return;}	 
     46c:	89 2b       	or	r24, r25
     46e:	a9 f5       	brne	.+106    	; 0x4da <LCD_write_num+0x80>
     470:	80 e3       	ldi	r24, 0x30	; 48
     472:	84 0f       	add	r24, r20
     474:	0e 94 bd 01 	call	0x37a	; 0x37a <LCD_write_char>
     478:	44 c0       	rjmp	.+136    	; 0x502 <LCD_write_num+0xa8>
	uint8_t n[5]; int8_t i=0;
	//save every digit of num in our array separately  
	for(;num!=0;i++)
	{
		n[i]=(num%10) +'0';
     47a:	9a 01       	movw	r18, r20
     47c:	ad ec       	ldi	r26, 0xCD	; 205
     47e:	bc ec       	ldi	r27, 0xCC	; 204
     480:	0e 94 28 08 	call	0x1050	; 0x1050 <__umulhisi3>
     484:	96 95       	lsr	r25
     486:	87 95       	ror	r24
     488:	96 95       	lsr	r25
     48a:	87 95       	ror	r24
     48c:	96 95       	lsr	r25
     48e:	87 95       	ror	r24
     490:	9c 01       	movw	r18, r24
     492:	22 0f       	add	r18, r18
     494:	33 1f       	adc	r19, r19
     496:	88 0f       	add	r24, r24
     498:	99 1f       	adc	r25, r25
     49a:	88 0f       	add	r24, r24
     49c:	99 1f       	adc	r25, r25
     49e:	88 0f       	add	r24, r24
     4a0:	99 1f       	adc	r25, r25
     4a2:	82 0f       	add	r24, r18
     4a4:	93 1f       	adc	r25, r19
     4a6:	9a 01       	movw	r18, r20
     4a8:	28 1b       	sub	r18, r24
     4aa:	39 0b       	sbc	r19, r25
     4ac:	c9 01       	movw	r24, r18
     4ae:	e1 e0       	ldi	r30, 0x01	; 1
     4b0:	f0 e0       	ldi	r31, 0x00	; 0
     4b2:	ec 0f       	add	r30, r28
     4b4:	fd 1f       	adc	r31, r29
     4b6:	e1 0f       	add	r30, r17
     4b8:	f1 1d       	adc	r31, r1
     4ba:	17 fd       	sbrc	r17, 7
     4bc:	fa 95       	dec	r31
     4be:	80 5d       	subi	r24, 0xD0	; 208
     4c0:	80 83       	st	Z, r24
		num/=10;
     4c2:	9a 01       	movw	r18, r20
     4c4:	0e 94 28 08 	call	0x1050	; 0x1050 <__umulhisi3>
     4c8:	ac 01       	movw	r20, r24
     4ca:	56 95       	lsr	r21
     4cc:	47 95       	ror	r20
     4ce:	56 95       	lsr	r21
     4d0:	47 95       	ror	r20
     4d2:	56 95       	lsr	r21
     4d4:	47 95       	ror	r20

void LCD_write_num(uint16_t num){
	if (num ==0) {LCD_write_char(num+ '0');return;}	 
	uint8_t n[5]; int8_t i=0;
	//save every digit of num in our array separately  
	for(;num!=0;i++)
     4d6:	1f 5f       	subi	r17, 0xFF	; 255
     4d8:	01 c0       	rjmp	.+2      	; 0x4dc <LCD_write_num+0x82>
     4da:	10 e0       	ldi	r17, 0x00	; 0
     4dc:	41 15       	cp	r20, r1
     4de:	51 05       	cpc	r21, r1
     4e0:	61 f6       	brne	.-104    	; 0x47a <LCD_write_num+0x20>
	{
		n[i]=(num%10) +'0';
		num/=10;
	}
	i--;
     4e2:	11 50       	subi	r17, 0x01	; 1
	while(i!=-1){
     4e4:	0c c0       	rjmp	.+24     	; 0x4fe <LCD_write_num+0xa4>
		LCD_write_char(n[i]);
     4e6:	e1 e0       	ldi	r30, 0x01	; 1
     4e8:	f0 e0       	ldi	r31, 0x00	; 0
     4ea:	ec 0f       	add	r30, r28
     4ec:	fd 1f       	adc	r31, r29
     4ee:	e1 0f       	add	r30, r17
     4f0:	f1 1d       	adc	r31, r1
     4f2:	17 fd       	sbrc	r17, 7
     4f4:	fa 95       	dec	r31
     4f6:	80 81       	ld	r24, Z
     4f8:	0e 94 bd 01 	call	0x37a	; 0x37a <LCD_write_char>
		i--;
     4fc:	11 50       	subi	r17, 0x01	; 1
	{
		n[i]=(num%10) +'0';
		num/=10;
	}
	i--;
	while(i!=-1){
     4fe:	1f 3f       	cpi	r17, 0xFF	; 255
     500:	91 f7       	brne	.-28     	; 0x4e6 <LCD_write_num+0x8c>
		LCD_write_char(n[i]);
		i--;
	}
}
     502:	0f 90       	pop	r0
     504:	0f 90       	pop	r0
     506:	0f 90       	pop	r0
     508:	0f 90       	pop	r0
     50a:	0f 90       	pop	r0
     50c:	df 91       	pop	r29
     50e:	cf 91       	pop	r28
     510:	1f 91       	pop	r17
     512:	08 95       	ret

00000514 <LCD_write_string>:
* Purpose      : display a specific string on LCD
* Parameters   : uint8_t*: array of string which must end with null
* Return value : void
*****************************************************************************/

void LCD_write_string(uint8_t *str){
     514:	0f 93       	push	r16
     516:	1f 93       	push	r17
     518:	cf 93       	push	r28
     51a:	8c 01       	movw	r16, r24
	uint8_t i =0;
     51c:	c0 e0       	ldi	r28, 0x00	; 0
	for(;str[i]!='\0';i++){
     51e:	03 c0       	rjmp	.+6      	; 0x526 <LCD_write_string+0x12>
		LCD_write_char(str[i]);
     520:	0e 94 bd 01 	call	0x37a	; 0x37a <LCD_write_char>
* Return value : void
*****************************************************************************/

void LCD_write_string(uint8_t *str){
	uint8_t i =0;
	for(;str[i]!='\0';i++){
     524:	cf 5f       	subi	r28, 0xFF	; 255
     526:	f8 01       	movw	r30, r16
     528:	ec 0f       	add	r30, r28
     52a:	f1 1d       	adc	r31, r1
     52c:	80 81       	ld	r24, Z
     52e:	81 11       	cpse	r24, r1
     530:	f7 cf       	rjmp	.-18     	; 0x520 <LCD_write_string+0xc>
		LCD_write_char(str[i]);
	}
}
     532:	cf 91       	pop	r28
     534:	1f 91       	pop	r17
     536:	0f 91       	pop	r16
     538:	08 95       	ret

0000053a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     53a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     53c:	03 96       	adiw	r24, 0x03	; 3
     53e:	92 83       	std	Z+2, r25	; 0x02
     540:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     542:	2f ef       	ldi	r18, 0xFF	; 255
     544:	3f ef       	ldi	r19, 0xFF	; 255
     546:	34 83       	std	Z+4, r19	; 0x04
     548:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     54a:	96 83       	std	Z+6, r25	; 0x06
     54c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     54e:	90 87       	std	Z+8, r25	; 0x08
     550:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     552:	10 82       	st	Z, r1
     554:	08 95       	ret

00000556 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     556:	fc 01       	movw	r30, r24
     558:	11 86       	std	Z+9, r1	; 0x09
     55a:	10 86       	std	Z+8, r1	; 0x08
     55c:	08 95       	ret

0000055e <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     55e:	cf 93       	push	r28
     560:	df 93       	push	r29
     562:	9c 01       	movw	r18, r24
     564:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     566:	dc 01       	movw	r26, r24
     568:	11 96       	adiw	r26, 0x01	; 1
     56a:	cd 91       	ld	r28, X+
     56c:	dc 91       	ld	r29, X
     56e:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     570:	d3 83       	std	Z+3, r29	; 0x03
     572:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     574:	8c 81       	ldd	r24, Y+4	; 0x04
     576:	9d 81       	ldd	r25, Y+5	; 0x05
     578:	95 83       	std	Z+5, r25	; 0x05
     57a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     57c:	8c 81       	ldd	r24, Y+4	; 0x04
     57e:	9d 81       	ldd	r25, Y+5	; 0x05
     580:	dc 01       	movw	r26, r24
     582:	13 96       	adiw	r26, 0x03	; 3
     584:	7c 93       	st	X, r23
     586:	6e 93       	st	-X, r22
     588:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     58a:	7d 83       	std	Y+5, r23	; 0x05
     58c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     58e:	31 87       	std	Z+9, r19	; 0x09
     590:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     592:	f9 01       	movw	r30, r18
     594:	80 81       	ld	r24, Z
     596:	8f 5f       	subi	r24, 0xFF	; 255
     598:	80 83       	st	Z, r24
}
     59a:	df 91       	pop	r29
     59c:	cf 91       	pop	r28
     59e:	08 95       	ret

000005a0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5a0:	cf 93       	push	r28
     5a2:	df 93       	push	r29
     5a4:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     5a6:	48 81       	ld	r20, Y
     5a8:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     5aa:	4f 3f       	cpi	r20, 0xFF	; 255
     5ac:	2f ef       	ldi	r18, 0xFF	; 255
     5ae:	52 07       	cpc	r21, r18
     5b0:	21 f4       	brne	.+8      	; 0x5ba <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     5b2:	fc 01       	movw	r30, r24
     5b4:	a7 81       	ldd	r26, Z+7	; 0x07
     5b6:	b0 85       	ldd	r27, Z+8	; 0x08
     5b8:	0d c0       	rjmp	.+26     	; 0x5d4 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5ba:	dc 01       	movw	r26, r24
     5bc:	13 96       	adiw	r26, 0x03	; 3
     5be:	01 c0       	rjmp	.+2      	; 0x5c2 <vListInsert+0x22>
     5c0:	df 01       	movw	r26, r30
     5c2:	12 96       	adiw	r26, 0x02	; 2
     5c4:	ed 91       	ld	r30, X+
     5c6:	fc 91       	ld	r31, X
     5c8:	13 97       	sbiw	r26, 0x03	; 3
     5ca:	20 81       	ld	r18, Z
     5cc:	31 81       	ldd	r19, Z+1	; 0x01
     5ce:	42 17       	cp	r20, r18
     5d0:	53 07       	cpc	r21, r19
     5d2:	b0 f7       	brcc	.-20     	; 0x5c0 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     5d4:	12 96       	adiw	r26, 0x02	; 2
     5d6:	ed 91       	ld	r30, X+
     5d8:	fc 91       	ld	r31, X
     5da:	13 97       	sbiw	r26, 0x03	; 3
     5dc:	fb 83       	std	Y+3, r31	; 0x03
     5de:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     5e0:	d5 83       	std	Z+5, r29	; 0x05
     5e2:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     5e4:	bd 83       	std	Y+5, r27	; 0x05
     5e6:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     5e8:	13 96       	adiw	r26, 0x03	; 3
     5ea:	dc 93       	st	X, r29
     5ec:	ce 93       	st	-X, r28
     5ee:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     5f0:	99 87       	std	Y+9, r25	; 0x09
     5f2:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     5f4:	fc 01       	movw	r30, r24
     5f6:	20 81       	ld	r18, Z
     5f8:	2f 5f       	subi	r18, 0xFF	; 255
     5fa:	20 83       	st	Z, r18
}
     5fc:	df 91       	pop	r29
     5fe:	cf 91       	pop	r28
     600:	08 95       	ret

00000602 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     602:	cf 93       	push	r28
     604:	df 93       	push	r29
     606:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     608:	a0 85       	ldd	r26, Z+8	; 0x08
     60a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     60c:	c2 81       	ldd	r28, Z+2	; 0x02
     60e:	d3 81       	ldd	r29, Z+3	; 0x03
     610:	84 81       	ldd	r24, Z+4	; 0x04
     612:	95 81       	ldd	r25, Z+5	; 0x05
     614:	9d 83       	std	Y+5, r25	; 0x05
     616:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     618:	c4 81       	ldd	r28, Z+4	; 0x04
     61a:	d5 81       	ldd	r29, Z+5	; 0x05
     61c:	82 81       	ldd	r24, Z+2	; 0x02
     61e:	93 81       	ldd	r25, Z+3	; 0x03
     620:	9b 83       	std	Y+3, r25	; 0x03
     622:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     624:	11 96       	adiw	r26, 0x01	; 1
     626:	8d 91       	ld	r24, X+
     628:	9c 91       	ld	r25, X
     62a:	12 97       	sbiw	r26, 0x02	; 2
     62c:	e8 17       	cp	r30, r24
     62e:	f9 07       	cpc	r31, r25
     630:	31 f4       	brne	.+12     	; 0x63e <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     632:	84 81       	ldd	r24, Z+4	; 0x04
     634:	95 81       	ldd	r25, Z+5	; 0x05
     636:	12 96       	adiw	r26, 0x02	; 2
     638:	9c 93       	st	X, r25
     63a:	8e 93       	st	-X, r24
     63c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     63e:	11 86       	std	Z+9, r1	; 0x09
     640:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     642:	8c 91       	ld	r24, X
     644:	81 50       	subi	r24, 0x01	; 1
     646:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     648:	df 91       	pop	r29
     64a:	cf 91       	pop	r28
     64c:	08 95       	ret

0000064e <task1>:
/*  
RTOS_app Non-preemptive   
*/

void task1(void * p){
	uint8_t count1=0;
     64e:	c0 e0       	ldi	r28, 0x00	; 0
	while(1){
		
		LCD_write_command(0x80);
     650:	80 e8       	ldi	r24, 0x80	; 128
     652:	0e 94 13 01 	call	0x226	; 0x226 <LCD_write_command>
		
		LCD_write_string("from-task1:");
     656:	82 e6       	ldi	r24, 0x62	; 98
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	0e 94 8a 02 	call	0x514	; 0x514 <LCD_write_string>
		LCD_write_num(count1);
     65e:	8c 2f       	mov	r24, r28
     660:	90 e0       	ldi	r25, 0x00	; 0
     662:	0e 94 2d 02 	call	0x45a	; 0x45a <LCD_write_num>
		count1++;
     666:	cf 5f       	subi	r28, 0xFF	; 255
     668:	8f e3       	ldi	r24, 0x3F	; 63
     66a:	9c e9       	ldi	r25, 0x9C	; 156
     66c:	01 97       	sbiw	r24, 0x01	; 1
     66e:	f1 f7       	brne	.-4      	; 0x66c <task1+0x1e>
     670:	00 c0       	rjmp	.+0      	; 0x672 <task1+0x24>
     672:	00 00       	nop
		_delay_ms(10);
		vTaskDelay(1000);// 1s	
     674:	88 ee       	ldi	r24, 0xE8	; 232
     676:	93 e0       	ldi	r25, 0x03	; 3
     678:	0e 94 8b 07 	call	0xf16	; 0xf16 <vTaskDelay>
     67c:	e9 cf       	rjmp	.-46     	; 0x650 <task1+0x2>

0000067e <task2>:
	}
}

void task2(void * p){
	uint8_t count2 =255;
     67e:	cf ef       	ldi	r28, 0xFF	; 255
	while (1)
	{
		LCD_write_command(0xC0);
     680:	80 ec       	ldi	r24, 0xC0	; 192
     682:	0e 94 13 01 	call	0x226	; 0x226 <LCD_write_command>
		LCD_write_string("from-task2:");
     686:	8e e6       	ldi	r24, 0x6E	; 110
     688:	90 e0       	ldi	r25, 0x00	; 0
     68a:	0e 94 8a 02 	call	0x514	; 0x514 <LCD_write_string>
		LCD_write_num(count2);
     68e:	8c 2f       	mov	r24, r28
     690:	90 e0       	ldi	r25, 0x00	; 0
     692:	0e 94 2d 02 	call	0x45a	; 0x45a <LCD_write_num>
		count2--;
     696:	c1 50       	subi	r28, 0x01	; 1
     698:	8f e3       	ldi	r24, 0x3F	; 63
     69a:	9c e9       	ldi	r25, 0x9C	; 156
     69c:	01 97       	sbiw	r24, 0x01	; 1
     69e:	f1 f7       	brne	.-4      	; 0x69c <task2+0x1e>
     6a0:	00 c0       	rjmp	.+0      	; 0x6a2 <task2+0x24>
     6a2:	00 00       	nop
		_delay_ms(10);
		vTaskDelay(5000);// 5s
     6a4:	88 e8       	ldi	r24, 0x88	; 136
     6a6:	93 e1       	ldi	r25, 0x13	; 19
     6a8:	0e 94 8b 07 	call	0xf16	; 0xf16 <vTaskDelay>
     6ac:	e9 cf       	rjmp	.-46     	; 0x680 <task2+0x2>

000006ae <main>:
	}
}


int main(void)
{	LCD_init();
     6ae:	ef 92       	push	r14
     6b0:	ff 92       	push	r15
     6b2:	0f 93       	push	r16
     6b4:	0e 94 83 01 	call	0x306	; 0x306 <LCD_init>
	LCD_write_string("HELLO_RTOS");
     6b8:	8a e7       	ldi	r24, 0x7A	; 122
     6ba:	90 e0       	ldi	r25, 0x00	; 0
     6bc:	0e 94 8a 02 	call	0x514	; 0x514 <LCD_write_string>
     6c0:	2f ef       	ldi	r18, 0xFF	; 255
     6c2:	80 e7       	ldi	r24, 0x70	; 112
     6c4:	92 e0       	ldi	r25, 0x02	; 2
     6c6:	21 50       	subi	r18, 0x01	; 1
     6c8:	80 40       	sbci	r24, 0x00	; 0
     6ca:	90 40       	sbci	r25, 0x00	; 0
     6cc:	e1 f7       	brne	.-8      	; 0x6c6 <main+0x18>
     6ce:	00 c0       	rjmp	.+0      	; 0x6d0 <main+0x22>
     6d0:	00 00       	nop
	_delay_ms(50);
	xTaskCreate(task1,"t1",100,NULL,1,task1handle);
     6d2:	e0 90 83 04 	lds	r14, 0x0483	; 0x800483 <task1handle>
     6d6:	f0 90 84 04 	lds	r15, 0x0484	; 0x800484 <task1handle+0x1>
     6da:	01 e0       	ldi	r16, 0x01	; 1
     6dc:	20 e0       	ldi	r18, 0x00	; 0
     6de:	30 e0       	ldi	r19, 0x00	; 0
     6e0:	44 e6       	ldi	r20, 0x64	; 100
     6e2:	50 e0       	ldi	r21, 0x00	; 0
     6e4:	65 e8       	ldi	r22, 0x85	; 133
     6e6:	70 e0       	ldi	r23, 0x00	; 0
     6e8:	87 e2       	ldi	r24, 0x27	; 39
     6ea:	93 e0       	ldi	r25, 0x03	; 3
     6ec:	0e 94 13 06 	call	0xc26	; 0xc26 <xTaskCreate>
    xTaskCreate(task2,"t2",100,NULL,1,task2handle);
     6f0:	e0 90 81 04 	lds	r14, 0x0481	; 0x800481 <task2handle>
     6f4:	f0 90 82 04 	lds	r15, 0x0482	; 0x800482 <task2handle+0x1>
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	44 e6       	ldi	r20, 0x64	; 100
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	68 e8       	ldi	r22, 0x88	; 136
     702:	70 e0       	ldi	r23, 0x00	; 0
     704:	8f e3       	ldi	r24, 0x3F	; 63
     706:	93 e0       	ldi	r25, 0x03	; 3
     708:	0e 94 13 06 	call	0xc26	; 0xc26 <xTaskCreate>
	vTaskStartScheduler();
     70c:	0e 94 67 06 	call	0xcce	; 0xcce <vTaskStartScheduler>
}
     710:	80 e0       	ldi	r24, 0x00	; 0
     712:	90 e0       	ldi	r25, 0x00	; 0
     714:	0f 91       	pop	r16
     716:	ff 90       	pop	r15
     718:	ef 90       	pop	r14
     71a:	08 95       	ret

0000071c <prvSetupTimerInterrupt>:
	{
		vTaskSwitchContext();
	}
	portRESTORE_CONTEXT();

	asm volatile ( "ret" );
     71c:	1b bc       	out	0x2b, r1	; 43
     71e:	89 ef       	ldi	r24, 0xF9	; 249
     720:	8a bd       	out	0x2a, r24	; 42
     722:	8b e0       	ldi	r24, 0x0B	; 11
     724:	8e bd       	out	0x2e, r24	; 46
     726:	89 b7       	in	r24, 0x39	; 57
     728:	80 61       	ori	r24, 0x10	; 16
     72a:	89 bf       	out	0x39, r24	; 57
     72c:	08 95       	ret

0000072e <pxPortInitialiseStack>:
     72e:	31 e1       	ldi	r19, 0x11	; 17
     730:	fc 01       	movw	r30, r24
     732:	30 83       	st	Z, r19
     734:	31 97       	sbiw	r30, 0x01	; 1
     736:	22 e2       	ldi	r18, 0x22	; 34
     738:	20 83       	st	Z, r18
     73a:	31 97       	sbiw	r30, 0x01	; 1
     73c:	a3 e3       	ldi	r26, 0x33	; 51
     73e:	a0 83       	st	Z, r26
     740:	31 97       	sbiw	r30, 0x01	; 1
     742:	60 83       	st	Z, r22
     744:	31 97       	sbiw	r30, 0x01	; 1
     746:	70 83       	st	Z, r23
     748:	31 97       	sbiw	r30, 0x01	; 1
     74a:	10 82       	st	Z, r1
     74c:	31 97       	sbiw	r30, 0x01	; 1
     74e:	60 e8       	ldi	r22, 0x80	; 128
     750:	60 83       	st	Z, r22
     752:	31 97       	sbiw	r30, 0x01	; 1
     754:	10 82       	st	Z, r1
     756:	31 97       	sbiw	r30, 0x01	; 1
     758:	62 e0       	ldi	r22, 0x02	; 2
     75a:	60 83       	st	Z, r22
     75c:	31 97       	sbiw	r30, 0x01	; 1
     75e:	63 e0       	ldi	r22, 0x03	; 3
     760:	60 83       	st	Z, r22
     762:	31 97       	sbiw	r30, 0x01	; 1
     764:	64 e0       	ldi	r22, 0x04	; 4
     766:	60 83       	st	Z, r22
     768:	31 97       	sbiw	r30, 0x01	; 1
     76a:	65 e0       	ldi	r22, 0x05	; 5
     76c:	60 83       	st	Z, r22
     76e:	31 97       	sbiw	r30, 0x01	; 1
     770:	66 e0       	ldi	r22, 0x06	; 6
     772:	60 83       	st	Z, r22
     774:	31 97       	sbiw	r30, 0x01	; 1
     776:	67 e0       	ldi	r22, 0x07	; 7
     778:	60 83       	st	Z, r22
     77a:	31 97       	sbiw	r30, 0x01	; 1
     77c:	68 e0       	ldi	r22, 0x08	; 8
     77e:	60 83       	st	Z, r22
     780:	31 97       	sbiw	r30, 0x01	; 1
     782:	69 e0       	ldi	r22, 0x09	; 9
     784:	60 83       	st	Z, r22
     786:	31 97       	sbiw	r30, 0x01	; 1
     788:	60 e1       	ldi	r22, 0x10	; 16
     78a:	60 83       	st	Z, r22
     78c:	31 97       	sbiw	r30, 0x01	; 1
     78e:	30 83       	st	Z, r19
     790:	31 97       	sbiw	r30, 0x01	; 1
     792:	32 e1       	ldi	r19, 0x12	; 18
     794:	30 83       	st	Z, r19
     796:	31 97       	sbiw	r30, 0x01	; 1
     798:	33 e1       	ldi	r19, 0x13	; 19
     79a:	30 83       	st	Z, r19
     79c:	31 97       	sbiw	r30, 0x01	; 1
     79e:	34 e1       	ldi	r19, 0x14	; 20
     7a0:	30 83       	st	Z, r19
     7a2:	31 97       	sbiw	r30, 0x01	; 1
     7a4:	35 e1       	ldi	r19, 0x15	; 21
     7a6:	30 83       	st	Z, r19
     7a8:	31 97       	sbiw	r30, 0x01	; 1
     7aa:	36 e1       	ldi	r19, 0x16	; 22
     7ac:	30 83       	st	Z, r19
     7ae:	31 97       	sbiw	r30, 0x01	; 1
     7b0:	37 e1       	ldi	r19, 0x17	; 23
     7b2:	30 83       	st	Z, r19
     7b4:	31 97       	sbiw	r30, 0x01	; 1
     7b6:	38 e1       	ldi	r19, 0x18	; 24
     7b8:	30 83       	st	Z, r19
     7ba:	31 97       	sbiw	r30, 0x01	; 1
     7bc:	39 e1       	ldi	r19, 0x19	; 25
     7be:	30 83       	st	Z, r19
     7c0:	31 97       	sbiw	r30, 0x01	; 1
     7c2:	30 e2       	ldi	r19, 0x20	; 32
     7c4:	30 83       	st	Z, r19
     7c6:	31 97       	sbiw	r30, 0x01	; 1
     7c8:	31 e2       	ldi	r19, 0x21	; 33
     7ca:	30 83       	st	Z, r19
     7cc:	31 97       	sbiw	r30, 0x01	; 1
     7ce:	20 83       	st	Z, r18
     7d0:	31 97       	sbiw	r30, 0x01	; 1
     7d2:	23 e2       	ldi	r18, 0x23	; 35
     7d4:	20 83       	st	Z, r18
     7d6:	31 97       	sbiw	r30, 0x01	; 1
     7d8:	40 83       	st	Z, r20
     7da:	31 97       	sbiw	r30, 0x01	; 1
     7dc:	50 83       	st	Z, r21
     7de:	31 97       	sbiw	r30, 0x01	; 1
     7e0:	26 e2       	ldi	r18, 0x26	; 38
     7e2:	20 83       	st	Z, r18
     7e4:	31 97       	sbiw	r30, 0x01	; 1
     7e6:	27 e2       	ldi	r18, 0x27	; 39
     7e8:	20 83       	st	Z, r18
     7ea:	31 97       	sbiw	r30, 0x01	; 1
     7ec:	28 e2       	ldi	r18, 0x28	; 40
     7ee:	20 83       	st	Z, r18
     7f0:	31 97       	sbiw	r30, 0x01	; 1
     7f2:	29 e2       	ldi	r18, 0x29	; 41
     7f4:	20 83       	st	Z, r18
     7f6:	31 97       	sbiw	r30, 0x01	; 1
     7f8:	20 e3       	ldi	r18, 0x30	; 48
     7fa:	20 83       	st	Z, r18
     7fc:	31 97       	sbiw	r30, 0x01	; 1
     7fe:	21 e3       	ldi	r18, 0x31	; 49
     800:	20 83       	st	Z, r18
     802:	86 97       	sbiw	r24, 0x26	; 38
     804:	08 95       	ret

00000806 <xPortStartScheduler>:
     806:	0e 94 8e 03 	call	0x71c	; 0x71c <prvSetupTimerInterrupt>
     80a:	a0 91 0d 05 	lds	r26, 0x050D	; 0x80050d <pxCurrentTCB>
     80e:	b0 91 0e 05 	lds	r27, 0x050E	; 0x80050e <pxCurrentTCB+0x1>
     812:	cd 91       	ld	r28, X+
     814:	cd bf       	out	0x3d, r28	; 61
     816:	dd 91       	ld	r29, X+
     818:	de bf       	out	0x3e, r29	; 62
     81a:	ff 91       	pop	r31
     81c:	ef 91       	pop	r30
     81e:	df 91       	pop	r29
     820:	cf 91       	pop	r28
     822:	bf 91       	pop	r27
     824:	af 91       	pop	r26
     826:	9f 91       	pop	r25
     828:	8f 91       	pop	r24
     82a:	7f 91       	pop	r23
     82c:	6f 91       	pop	r22
     82e:	5f 91       	pop	r21
     830:	4f 91       	pop	r20
     832:	3f 91       	pop	r19
     834:	2f 91       	pop	r18
     836:	1f 91       	pop	r17
     838:	0f 91       	pop	r16
     83a:	ff 90       	pop	r15
     83c:	ef 90       	pop	r14
     83e:	df 90       	pop	r13
     840:	cf 90       	pop	r12
     842:	bf 90       	pop	r11
     844:	af 90       	pop	r10
     846:	9f 90       	pop	r9
     848:	8f 90       	pop	r8
     84a:	7f 90       	pop	r7
     84c:	6f 90       	pop	r6
     84e:	5f 90       	pop	r5
     850:	4f 90       	pop	r4
     852:	3f 90       	pop	r3
     854:	2f 90       	pop	r2
     856:	1f 90       	pop	r1
     858:	0f 90       	pop	r0
     85a:	0f be       	out	0x3f, r0	; 63
     85c:	0f 90       	pop	r0
     85e:	08 95       	ret
     860:	81 e0       	ldi	r24, 0x01	; 1
     862:	08 95       	ret

00000864 <vPortYield>:
     864:	0f 92       	push	r0
     866:	0f b6       	in	r0, 0x3f	; 63
     868:	f8 94       	cli
     86a:	0f 92       	push	r0
     86c:	1f 92       	push	r1
     86e:	11 24       	eor	r1, r1
     870:	2f 92       	push	r2
     872:	3f 92       	push	r3
     874:	4f 92       	push	r4
     876:	5f 92       	push	r5
     878:	6f 92       	push	r6
     87a:	7f 92       	push	r7
     87c:	8f 92       	push	r8
     87e:	9f 92       	push	r9
     880:	af 92       	push	r10
     882:	bf 92       	push	r11
     884:	cf 92       	push	r12
     886:	df 92       	push	r13
     888:	ef 92       	push	r14
     88a:	ff 92       	push	r15
     88c:	0f 93       	push	r16
     88e:	1f 93       	push	r17
     890:	2f 93       	push	r18
     892:	3f 93       	push	r19
     894:	4f 93       	push	r20
     896:	5f 93       	push	r21
     898:	6f 93       	push	r22
     89a:	7f 93       	push	r23
     89c:	8f 93       	push	r24
     89e:	9f 93       	push	r25
     8a0:	af 93       	push	r26
     8a2:	bf 93       	push	r27
     8a4:	cf 93       	push	r28
     8a6:	df 93       	push	r29
     8a8:	ef 93       	push	r30
     8aa:	ff 93       	push	r31
     8ac:	a0 91 0d 05 	lds	r26, 0x050D	; 0x80050d <pxCurrentTCB>
     8b0:	b0 91 0e 05 	lds	r27, 0x050E	; 0x80050e <pxCurrentTCB+0x1>
     8b4:	0d b6       	in	r0, 0x3d	; 61
     8b6:	0d 92       	st	X+, r0
     8b8:	0e b6       	in	r0, 0x3e	; 62
     8ba:	0d 92       	st	X+, r0
     8bc:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <vTaskSwitchContext>
     8c0:	a0 91 0d 05 	lds	r26, 0x050D	; 0x80050d <pxCurrentTCB>
     8c4:	b0 91 0e 05 	lds	r27, 0x050E	; 0x80050e <pxCurrentTCB+0x1>
     8c8:	cd 91       	ld	r28, X+
     8ca:	cd bf       	out	0x3d, r28	; 61
     8cc:	dd 91       	ld	r29, X+
     8ce:	de bf       	out	0x3e, r29	; 62
     8d0:	ff 91       	pop	r31
     8d2:	ef 91       	pop	r30
     8d4:	df 91       	pop	r29
     8d6:	cf 91       	pop	r28
     8d8:	bf 91       	pop	r27
     8da:	af 91       	pop	r26
     8dc:	9f 91       	pop	r25
     8de:	8f 91       	pop	r24
     8e0:	7f 91       	pop	r23
     8e2:	6f 91       	pop	r22
     8e4:	5f 91       	pop	r21
     8e6:	4f 91       	pop	r20
     8e8:	3f 91       	pop	r19
     8ea:	2f 91       	pop	r18
     8ec:	1f 91       	pop	r17
     8ee:	0f 91       	pop	r16
     8f0:	ff 90       	pop	r15
     8f2:	ef 90       	pop	r14
     8f4:	df 90       	pop	r13
     8f6:	cf 90       	pop	r12
     8f8:	bf 90       	pop	r11
     8fa:	af 90       	pop	r10
     8fc:	9f 90       	pop	r9
     8fe:	8f 90       	pop	r8
     900:	7f 90       	pop	r7
     902:	6f 90       	pop	r6
     904:	5f 90       	pop	r5
     906:	4f 90       	pop	r4
     908:	3f 90       	pop	r3
     90a:	2f 90       	pop	r2
     90c:	1f 90       	pop	r1
     90e:	0f 90       	pop	r0
     910:	0f be       	out	0x3f, r0	; 63
     912:	0f 90       	pop	r0
     914:	08 95       	ret

00000916 <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal ) );
	void TIMER1_COMPA_vect( void )
	{
     916:	1f 92       	push	r1
     918:	0f 92       	push	r0
     91a:	0f b6       	in	r0, 0x3f	; 63
     91c:	0f 92       	push	r0
     91e:	11 24       	eor	r1, r1
     920:	2f 93       	push	r18
     922:	3f 93       	push	r19
     924:	4f 93       	push	r20
     926:	5f 93       	push	r21
     928:	6f 93       	push	r22
     92a:	7f 93       	push	r23
     92c:	8f 93       	push	r24
     92e:	9f 93       	push	r25
     930:	af 93       	push	r26
     932:	bf 93       	push	r27
     934:	ef 93       	push	r30
     936:	ff 93       	push	r31
		xTaskIncrementTick();
     938:	0e 94 97 06 	call	0xd2e	; 0xd2e <xTaskIncrementTick>
	}
     93c:	ff 91       	pop	r31
     93e:	ef 91       	pop	r30
     940:	bf 91       	pop	r27
     942:	af 91       	pop	r26
     944:	9f 91       	pop	r25
     946:	8f 91       	pop	r24
     948:	7f 91       	pop	r23
     94a:	6f 91       	pop	r22
     94c:	5f 91       	pop	r21
     94e:	4f 91       	pop	r20
     950:	3f 91       	pop	r19
     952:	2f 91       	pop	r18
     954:	0f 90       	pop	r0
     956:	0f be       	out	0x3f, r0	; 63
     958:	0f 90       	pop	r0
     95a:	1f 90       	pop	r1
     95c:	18 95       	reti

0000095e <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     95e:	e0 91 a8 04 	lds	r30, 0x04A8	; 0x8004a8 <pxDelayedTaskList>
     962:	f0 91 a9 04 	lds	r31, 0x04A9	; 0x8004a9 <pxDelayedTaskList+0x1>
     966:	80 81       	ld	r24, Z
     968:	81 11       	cpse	r24, r1
     96a:	07 c0       	rjmp	.+14     	; 0x97a <prvResetNextTaskUnblockTime+0x1c>
     96c:	8f ef       	ldi	r24, 0xFF	; 255
     96e:	9f ef       	ldi	r25, 0xFF	; 255
     970:	90 93 89 04 	sts	0x0489, r25	; 0x800489 <xNextTaskUnblockTime+0x1>
     974:	80 93 88 04 	sts	0x0488, r24	; 0x800488 <xNextTaskUnblockTime>
     978:	08 95       	ret
     97a:	e0 91 a8 04 	lds	r30, 0x04A8	; 0x8004a8 <pxDelayedTaskList>
     97e:	f0 91 a9 04 	lds	r31, 0x04A9	; 0x8004a9 <pxDelayedTaskList+0x1>
     982:	05 80       	ldd	r0, Z+5	; 0x05
     984:	f6 81       	ldd	r31, Z+6	; 0x06
     986:	e0 2d       	mov	r30, r0
     988:	06 80       	ldd	r0, Z+6	; 0x06
     98a:	f7 81       	ldd	r31, Z+7	; 0x07
     98c:	e0 2d       	mov	r30, r0
     98e:	82 81       	ldd	r24, Z+2	; 0x02
     990:	93 81       	ldd	r25, Z+3	; 0x03
     992:	90 93 89 04 	sts	0x0489, r25	; 0x800489 <xNextTaskUnblockTime+0x1>
     996:	80 93 88 04 	sts	0x0488, r24	; 0x800488 <xNextTaskUnblockTime>
     99a:	08 95       	ret

0000099c <prvDeleteTCB>:
     99c:	cf 93       	push	r28
     99e:	df 93       	push	r29
     9a0:	ec 01       	movw	r28, r24
     9a2:	8f 89       	ldd	r24, Y+23	; 0x17
     9a4:	98 8d       	ldd	r25, Y+24	; 0x18
     9a6:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <vPortFree>
     9aa:	ce 01       	movw	r24, r28
     9ac:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <vPortFree>
     9b0:	df 91       	pop	r29
     9b2:	cf 91       	pop	r28
     9b4:	08 95       	ret

000009b6 <prvInitialiseNewTask>:
     9b6:	6f 92       	push	r6
     9b8:	7f 92       	push	r7
     9ba:	8f 92       	push	r8
     9bc:	9f 92       	push	r9
     9be:	af 92       	push	r10
     9c0:	bf 92       	push	r11
     9c2:	cf 92       	push	r12
     9c4:	df 92       	push	r13
     9c6:	ef 92       	push	r14
     9c8:	0f 93       	push	r16
     9ca:	1f 93       	push	r17
     9cc:	cf 93       	push	r28
     9ce:	df 93       	push	r29
     9d0:	cd b7       	in	r28, 0x3d	; 61
     9d2:	de b7       	in	r29, 0x3e	; 62
     9d4:	4c 01       	movw	r8, r24
     9d6:	f5 01       	movw	r30, r10
     9d8:	87 89       	ldd	r24, Z+23	; 0x17
     9da:	90 8d       	ldd	r25, Z+24	; 0x18
     9dc:	21 50       	subi	r18, 0x01	; 1
     9de:	31 09       	sbc	r19, r1
     9e0:	3c 01       	movw	r6, r24
     9e2:	62 0e       	add	r6, r18
     9e4:	73 1e       	adc	r7, r19
     9e6:	20 e0       	ldi	r18, 0x00	; 0
     9e8:	0f c0       	rjmp	.+30     	; 0xa08 <prvInitialiseNewTask+0x52>
     9ea:	82 2f       	mov	r24, r18
     9ec:	90 e0       	ldi	r25, 0x00	; 0
     9ee:	fb 01       	movw	r30, r22
     9f0:	e8 0f       	add	r30, r24
     9f2:	f9 1f       	adc	r31, r25
     9f4:	30 81       	ld	r19, Z
     9f6:	d5 01       	movw	r26, r10
     9f8:	a8 0f       	add	r26, r24
     9fa:	b9 1f       	adc	r27, r25
     9fc:	59 96       	adiw	r26, 0x19	; 25
     9fe:	3c 93       	st	X, r19
     a00:	80 81       	ld	r24, Z
     a02:	88 23       	and	r24, r24
     a04:	19 f0       	breq	.+6      	; 0xa0c <prvInitialiseNewTask+0x56>
     a06:	2f 5f       	subi	r18, 0xFF	; 255
     a08:	28 30       	cpi	r18, 0x08	; 8
     a0a:	78 f3       	brcs	.-34     	; 0x9ea <prvInitialiseNewTask+0x34>
     a0c:	f5 01       	movw	r30, r10
     a0e:	10 a2       	std	Z+32, r1	; 0x20
     a10:	f8 e0       	ldi	r31, 0x08	; 8
     a12:	fe 15       	cp	r31, r14
     a14:	18 f4       	brcc	.+6      	; 0xa1c <prvInitialiseNewTask+0x66>
     a16:	68 94       	set
     a18:	ee 24       	eor	r14, r14
     a1a:	e3 f8       	bld	r14, 3
     a1c:	f5 01       	movw	r30, r10
     a1e:	e6 8a       	std	Z+22, r14	; 0x16
     a20:	e1 a2       	std	Z+33, r14	; 0x21
     a22:	12 a2       	std	Z+34, r1	; 0x22
     a24:	c5 01       	movw	r24, r10
     a26:	02 96       	adiw	r24, 0x02	; 2
     a28:	0e 94 ab 02 	call	0x556	; 0x556 <vListInitialiseItem>
     a2c:	c5 01       	movw	r24, r10
     a2e:	0c 96       	adiw	r24, 0x0c	; 12
     a30:	0e 94 ab 02 	call	0x556	; 0x556 <vListInitialiseItem>
     a34:	f5 01       	movw	r30, r10
     a36:	b1 86       	std	Z+9, r11	; 0x09
     a38:	a0 86       	std	Z+8, r10	; 0x08
     a3a:	89 e0       	ldi	r24, 0x09	; 9
     a3c:	90 e0       	ldi	r25, 0x00	; 0
     a3e:	8e 19       	sub	r24, r14
     a40:	91 09       	sbc	r25, r1
     a42:	95 87       	std	Z+13, r25	; 0x0d
     a44:	84 87       	std	Z+12, r24	; 0x0c
     a46:	b3 8a       	std	Z+19, r11	; 0x13
     a48:	a2 8a       	std	Z+18, r10	; 0x12
     a4a:	13 a2       	std	Z+35, r1	; 0x23
     a4c:	14 a2       	std	Z+36, r1	; 0x24
     a4e:	15 a2       	std	Z+37, r1	; 0x25
     a50:	16 a2       	std	Z+38, r1	; 0x26
     a52:	17 a2       	std	Z+39, r1	; 0x27
     a54:	a8 01       	movw	r20, r16
     a56:	b4 01       	movw	r22, r8
     a58:	c3 01       	movw	r24, r6
     a5a:	0e 94 97 03 	call	0x72e	; 0x72e <pxPortInitialiseStack>
     a5e:	f5 01       	movw	r30, r10
     a60:	91 83       	std	Z+1, r25	; 0x01
     a62:	80 83       	st	Z, r24
     a64:	c1 14       	cp	r12, r1
     a66:	d1 04       	cpc	r13, r1
     a68:	19 f0       	breq	.+6      	; 0xa70 <prvInitialiseNewTask+0xba>
     a6a:	f6 01       	movw	r30, r12
     a6c:	b1 82       	std	Z+1, r11	; 0x01
     a6e:	a0 82       	st	Z, r10
     a70:	df 91       	pop	r29
     a72:	cf 91       	pop	r28
     a74:	1f 91       	pop	r17
     a76:	0f 91       	pop	r16
     a78:	ef 90       	pop	r14
     a7a:	df 90       	pop	r13
     a7c:	cf 90       	pop	r12
     a7e:	bf 90       	pop	r11
     a80:	af 90       	pop	r10
     a82:	9f 90       	pop	r9
     a84:	8f 90       	pop	r8
     a86:	7f 90       	pop	r7
     a88:	6f 90       	pop	r6
     a8a:	08 95       	ret

00000a8c <prvInitialiseTaskLists>:
     a8c:	cf 93       	push	r28
     a8e:	c0 e0       	ldi	r28, 0x00	; 0
     a90:	10 c0       	rjmp	.+32     	; 0xab2 <prvInitialiseTaskLists+0x26>
     a92:	8c 2f       	mov	r24, r28
     a94:	90 e0       	ldi	r25, 0x00	; 0
     a96:	9c 01       	movw	r18, r24
     a98:	22 0f       	add	r18, r18
     a9a:	33 1f       	adc	r19, r19
     a9c:	22 0f       	add	r18, r18
     a9e:	33 1f       	adc	r19, r19
     aa0:	22 0f       	add	r18, r18
     aa2:	33 1f       	adc	r19, r19
     aa4:	82 0f       	add	r24, r18
     aa6:	93 1f       	adc	r25, r19
     aa8:	84 54       	subi	r24, 0x44	; 68
     aaa:	9b 4f       	sbci	r25, 0xFB	; 251
     aac:	0e 94 9d 02 	call	0x53a	; 0x53a <vListInitialise>
     ab0:	cf 5f       	subi	r28, 0xFF	; 255
     ab2:	c9 30       	cpi	r28, 0x09	; 9
     ab4:	70 f3       	brcs	.-36     	; 0xa92 <prvInitialiseTaskLists+0x6>
     ab6:	83 eb       	ldi	r24, 0xB3	; 179
     ab8:	94 e0       	ldi	r25, 0x04	; 4
     aba:	0e 94 9d 02 	call	0x53a	; 0x53a <vListInitialise>
     abe:	8a ea       	ldi	r24, 0xAA	; 170
     ac0:	94 e0       	ldi	r25, 0x04	; 4
     ac2:	0e 94 9d 02 	call	0x53a	; 0x53a <vListInitialise>
     ac6:	8d e9       	ldi	r24, 0x9D	; 157
     ac8:	94 e0       	ldi	r25, 0x04	; 4
     aca:	0e 94 9d 02 	call	0x53a	; 0x53a <vListInitialise>
     ace:	84 e9       	ldi	r24, 0x94	; 148
     ad0:	94 e0       	ldi	r25, 0x04	; 4
     ad2:	0e 94 9d 02 	call	0x53a	; 0x53a <vListInitialise>
     ad6:	83 eb       	ldi	r24, 0xB3	; 179
     ad8:	94 e0       	ldi	r25, 0x04	; 4
     ada:	90 93 a9 04 	sts	0x04A9, r25	; 0x8004a9 <pxDelayedTaskList+0x1>
     ade:	80 93 a8 04 	sts	0x04A8, r24	; 0x8004a8 <pxDelayedTaskList>
     ae2:	8a ea       	ldi	r24, 0xAA	; 170
     ae4:	94 e0       	ldi	r25, 0x04	; 4
     ae6:	90 93 a7 04 	sts	0x04A7, r25	; 0x8004a7 <pxOverflowDelayedTaskList+0x1>
     aea:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <pxOverflowDelayedTaskList>
     aee:	cf 91       	pop	r28
     af0:	08 95       	ret

00000af2 <prvAddNewTaskToReadyList>:
     af2:	cf 93       	push	r28
     af4:	df 93       	push	r29
     af6:	ec 01       	movw	r28, r24
     af8:	0f b6       	in	r0, 0x3f	; 63
     afa:	f8 94       	cli
     afc:	0f 92       	push	r0
     afe:	80 91 92 04 	lds	r24, 0x0492	; 0x800492 <uxCurrentNumberOfTasks>
     b02:	8f 5f       	subi	r24, 0xFF	; 255
     b04:	80 93 92 04 	sts	0x0492, r24	; 0x800492 <uxCurrentNumberOfTasks>
     b08:	80 91 0d 05 	lds	r24, 0x050D	; 0x80050d <pxCurrentTCB>
     b0c:	90 91 0e 05 	lds	r25, 0x050E	; 0x80050e <pxCurrentTCB+0x1>
     b10:	89 2b       	or	r24, r25
     b12:	59 f4       	brne	.+22     	; 0xb2a <prvAddNewTaskToReadyList+0x38>
     b14:	d0 93 0e 05 	sts	0x050E, r29	; 0x80050e <pxCurrentTCB+0x1>
     b18:	c0 93 0d 05 	sts	0x050D, r28	; 0x80050d <pxCurrentTCB>
     b1c:	80 91 92 04 	lds	r24, 0x0492	; 0x800492 <uxCurrentNumberOfTasks>
     b20:	81 30       	cpi	r24, 0x01	; 1
     b22:	99 f4       	brne	.+38     	; 0xb4a <prvAddNewTaskToReadyList+0x58>
     b24:	0e 94 46 05 	call	0xa8c	; 0xa8c <prvInitialiseTaskLists>
     b28:	10 c0       	rjmp	.+32     	; 0xb4a <prvAddNewTaskToReadyList+0x58>
     b2a:	80 91 8e 04 	lds	r24, 0x048E	; 0x80048e <xSchedulerRunning>
     b2e:	81 11       	cpse	r24, r1
     b30:	0c c0       	rjmp	.+24     	; 0xb4a <prvAddNewTaskToReadyList+0x58>
     b32:	e0 91 0d 05 	lds	r30, 0x050D	; 0x80050d <pxCurrentTCB>
     b36:	f0 91 0e 05 	lds	r31, 0x050E	; 0x80050e <pxCurrentTCB+0x1>
     b3a:	96 89       	ldd	r25, Z+22	; 0x16
     b3c:	8e 89       	ldd	r24, Y+22	; 0x16
     b3e:	89 17       	cp	r24, r25
     b40:	20 f0       	brcs	.+8      	; 0xb4a <prvAddNewTaskToReadyList+0x58>
     b42:	d0 93 0e 05 	sts	0x050E, r29	; 0x80050e <pxCurrentTCB+0x1>
     b46:	c0 93 0d 05 	sts	0x050D, r28	; 0x80050d <pxCurrentTCB>
     b4a:	80 91 8a 04 	lds	r24, 0x048A	; 0x80048a <uxTaskNumber>
     b4e:	8f 5f       	subi	r24, 0xFF	; 255
     b50:	80 93 8a 04 	sts	0x048A, r24	; 0x80048a <uxTaskNumber>
     b54:	2e 89       	ldd	r18, Y+22	; 0x16
     b56:	80 91 8f 04 	lds	r24, 0x048F	; 0x80048f <uxTopReadyPriority>
     b5a:	82 17       	cp	r24, r18
     b5c:	10 f4       	brcc	.+4      	; 0xb62 <prvAddNewTaskToReadyList+0x70>
     b5e:	20 93 8f 04 	sts	0x048F, r18	; 0x80048f <uxTopReadyPriority>
     b62:	30 e0       	ldi	r19, 0x00	; 0
     b64:	be 01       	movw	r22, r28
     b66:	6e 5f       	subi	r22, 0xFE	; 254
     b68:	7f 4f       	sbci	r23, 0xFF	; 255
     b6a:	c9 01       	movw	r24, r18
     b6c:	88 0f       	add	r24, r24
     b6e:	99 1f       	adc	r25, r25
     b70:	88 0f       	add	r24, r24
     b72:	99 1f       	adc	r25, r25
     b74:	88 0f       	add	r24, r24
     b76:	99 1f       	adc	r25, r25
     b78:	82 0f       	add	r24, r18
     b7a:	93 1f       	adc	r25, r19
     b7c:	84 54       	subi	r24, 0x44	; 68
     b7e:	9b 4f       	sbci	r25, 0xFB	; 251
     b80:	0e 94 af 02 	call	0x55e	; 0x55e <vListInsertEnd>
     b84:	0f 90       	pop	r0
     b86:	0f be       	out	0x3f, r0	; 63
     b88:	80 91 8e 04 	lds	r24, 0x048E	; 0x80048e <xSchedulerRunning>
     b8c:	88 23       	and	r24, r24
     b8e:	21 f0       	breq	.+8      	; 0xb98 <prvAddNewTaskToReadyList+0xa6>
     b90:	80 91 0d 05 	lds	r24, 0x050D	; 0x80050d <pxCurrentTCB>
     b94:	90 91 0e 05 	lds	r25, 0x050E	; 0x80050e <pxCurrentTCB+0x1>
     b98:	df 91       	pop	r29
     b9a:	cf 91       	pop	r28
     b9c:	08 95       	ret

00000b9e <prvAddCurrentTaskToDelayedList>:
     b9e:	0f 93       	push	r16
     ba0:	1f 93       	push	r17
     ba2:	cf 93       	push	r28
     ba4:	df 93       	push	r29
     ba6:	ec 01       	movw	r28, r24
     ba8:	00 91 90 04 	lds	r16, 0x0490	; 0x800490 <xTickCount>
     bac:	10 91 91 04 	lds	r17, 0x0491	; 0x800491 <xTickCount+0x1>
     bb0:	80 91 0d 05 	lds	r24, 0x050D	; 0x80050d <pxCurrentTCB>
     bb4:	90 91 0e 05 	lds	r25, 0x050E	; 0x80050e <pxCurrentTCB+0x1>
     bb8:	02 96       	adiw	r24, 0x02	; 2
     bba:	0e 94 01 03 	call	0x602	; 0x602 <uxListRemove>
     bbe:	c0 0f       	add	r28, r16
     bc0:	d1 1f       	adc	r29, r17
     bc2:	e0 91 0d 05 	lds	r30, 0x050D	; 0x80050d <pxCurrentTCB>
     bc6:	f0 91 0e 05 	lds	r31, 0x050E	; 0x80050e <pxCurrentTCB+0x1>
     bca:	d3 83       	std	Z+3, r29	; 0x03
     bcc:	c2 83       	std	Z+2, r28	; 0x02
     bce:	c0 17       	cp	r28, r16
     bd0:	d1 07       	cpc	r29, r17
     bd2:	68 f4       	brcc	.+26     	; 0xbee <prvAddCurrentTaskToDelayedList+0x50>
     bd4:	60 91 0d 05 	lds	r22, 0x050D	; 0x80050d <pxCurrentTCB>
     bd8:	70 91 0e 05 	lds	r23, 0x050E	; 0x80050e <pxCurrentTCB+0x1>
     bdc:	80 91 a6 04 	lds	r24, 0x04A6	; 0x8004a6 <pxOverflowDelayedTaskList>
     be0:	90 91 a7 04 	lds	r25, 0x04A7	; 0x8004a7 <pxOverflowDelayedTaskList+0x1>
     be4:	6e 5f       	subi	r22, 0xFE	; 254
     be6:	7f 4f       	sbci	r23, 0xFF	; 255
     be8:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <vListInsert>
     bec:	17 c0       	rjmp	.+46     	; 0xc1c <prvAddCurrentTaskToDelayedList+0x7e>
     bee:	60 91 0d 05 	lds	r22, 0x050D	; 0x80050d <pxCurrentTCB>
     bf2:	70 91 0e 05 	lds	r23, 0x050E	; 0x80050e <pxCurrentTCB+0x1>
     bf6:	80 91 a8 04 	lds	r24, 0x04A8	; 0x8004a8 <pxDelayedTaskList>
     bfa:	90 91 a9 04 	lds	r25, 0x04A9	; 0x8004a9 <pxDelayedTaskList+0x1>
     bfe:	6e 5f       	subi	r22, 0xFE	; 254
     c00:	7f 4f       	sbci	r23, 0xFF	; 255
     c02:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <vListInsert>
     c06:	80 91 88 04 	lds	r24, 0x0488	; 0x800488 <xNextTaskUnblockTime>
     c0a:	90 91 89 04 	lds	r25, 0x0489	; 0x800489 <xNextTaskUnblockTime+0x1>
     c0e:	c8 17       	cp	r28, r24
     c10:	d9 07       	cpc	r29, r25
     c12:	20 f4       	brcc	.+8      	; 0xc1c <prvAddCurrentTaskToDelayedList+0x7e>
     c14:	d0 93 89 04 	sts	0x0489, r29	; 0x800489 <xNextTaskUnblockTime+0x1>
     c18:	c0 93 88 04 	sts	0x0488, r28	; 0x800488 <xNextTaskUnblockTime>
     c1c:	df 91       	pop	r29
     c1e:	cf 91       	pop	r28
     c20:	1f 91       	pop	r17
     c22:	0f 91       	pop	r16
     c24:	08 95       	ret

00000c26 <xTaskCreate>:
     c26:	2f 92       	push	r2
     c28:	3f 92       	push	r3
     c2a:	4f 92       	push	r4
     c2c:	5f 92       	push	r5
     c2e:	6f 92       	push	r6
     c30:	7f 92       	push	r7
     c32:	8f 92       	push	r8
     c34:	9f 92       	push	r9
     c36:	af 92       	push	r10
     c38:	bf 92       	push	r11
     c3a:	cf 92       	push	r12
     c3c:	df 92       	push	r13
     c3e:	ef 92       	push	r14
     c40:	ff 92       	push	r15
     c42:	0f 93       	push	r16
     c44:	1f 93       	push	r17
     c46:	cf 93       	push	r28
     c48:	df 93       	push	r29
     c4a:	3c 01       	movw	r6, r24
     c4c:	1b 01       	movw	r2, r22
     c4e:	5a 01       	movw	r10, r20
     c50:	29 01       	movw	r4, r18
     c52:	ca 01       	movw	r24, r20
     c54:	0e 94 64 00 	call	0xc8	; 0xc8 <pvPortMalloc>
     c58:	6c 01       	movw	r12, r24
     c5a:	89 2b       	or	r24, r25
     c5c:	71 f0       	breq	.+28     	; 0xc7a <xTaskCreate+0x54>
     c5e:	88 e2       	ldi	r24, 0x28	; 40
     c60:	90 e0       	ldi	r25, 0x00	; 0
     c62:	0e 94 64 00 	call	0xc8	; 0xc8 <pvPortMalloc>
     c66:	ec 01       	movw	r28, r24
     c68:	89 2b       	or	r24, r25
     c6a:	19 f0       	breq	.+6      	; 0xc72 <xTaskCreate+0x4c>
     c6c:	d8 8e       	std	Y+24, r13	; 0x18
     c6e:	cf 8a       	std	Y+23, r12	; 0x17
     c70:	06 c0       	rjmp	.+12     	; 0xc7e <xTaskCreate+0x58>
     c72:	c6 01       	movw	r24, r12
     c74:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <vPortFree>
     c78:	02 c0       	rjmp	.+4      	; 0xc7e <xTaskCreate+0x58>
     c7a:	c0 e0       	ldi	r28, 0x00	; 0
     c7c:	d0 e0       	ldi	r29, 0x00	; 0
     c7e:	20 97       	sbiw	r28, 0x00	; 0
     c80:	91 f0       	breq	.+36     	; 0xca6 <xTaskCreate+0x80>
     c82:	95 01       	movw	r18, r10
     c84:	40 e0       	ldi	r20, 0x00	; 0
     c86:	50 e0       	ldi	r21, 0x00	; 0
     c88:	81 2c       	mov	r8, r1
     c8a:	91 2c       	mov	r9, r1
     c8c:	5e 01       	movw	r10, r28
     c8e:	67 01       	movw	r12, r14
     c90:	e0 2e       	mov	r14, r16
     c92:	82 01       	movw	r16, r4
     c94:	b1 01       	movw	r22, r2
     c96:	c3 01       	movw	r24, r6
     c98:	0e 94 db 04 	call	0x9b6	; 0x9b6 <prvInitialiseNewTask>
     c9c:	ce 01       	movw	r24, r28
     c9e:	0e 94 79 05 	call	0xaf2	; 0xaf2 <prvAddNewTaskToReadyList>
     ca2:	81 e0       	ldi	r24, 0x01	; 1
     ca4:	01 c0       	rjmp	.+2      	; 0xca8 <xTaskCreate+0x82>
     ca6:	8f ef       	ldi	r24, 0xFF	; 255
     ca8:	df 91       	pop	r29
     caa:	cf 91       	pop	r28
     cac:	1f 91       	pop	r17
     cae:	0f 91       	pop	r16
     cb0:	ff 90       	pop	r15
     cb2:	ef 90       	pop	r14
     cb4:	df 90       	pop	r13
     cb6:	cf 90       	pop	r12
     cb8:	bf 90       	pop	r11
     cba:	af 90       	pop	r10
     cbc:	9f 90       	pop	r9
     cbe:	8f 90       	pop	r8
     cc0:	7f 90       	pop	r7
     cc2:	6f 90       	pop	r6
     cc4:	5f 90       	pop	r5
     cc6:	4f 90       	pop	r4
     cc8:	3f 90       	pop	r3
     cca:	2f 90       	pop	r2
     ccc:	08 95       	ret

00000cce <vTaskStartScheduler>:
     cce:	ef 92       	push	r14
     cd0:	ff 92       	push	r15
     cd2:	0f 93       	push	r16
     cd4:	0f 2e       	mov	r0, r31
     cd6:	f6 e8       	ldi	r31, 0x86	; 134
     cd8:	ef 2e       	mov	r14, r31
     cda:	f4 e0       	ldi	r31, 0x04	; 4
     cdc:	ff 2e       	mov	r15, r31
     cde:	f0 2d       	mov	r31, r0
     ce0:	00 e0       	ldi	r16, 0x00	; 0
     ce2:	20 e0       	ldi	r18, 0x00	; 0
     ce4:	30 e0       	ldi	r19, 0x00	; 0
     ce6:	40 e5       	ldi	r20, 0x50	; 80
     ce8:	50 e0       	ldi	r21, 0x00	; 0
     cea:	6b e8       	ldi	r22, 0x8B	; 139
     cec:	70 e0       	ldi	r23, 0x00	; 0
     cee:	8f ec       	ldi	r24, 0xCF	; 207
     cf0:	97 e0       	ldi	r25, 0x07	; 7
     cf2:	0e 94 13 06 	call	0xc26	; 0xc26 <xTaskCreate>
     cf6:	81 30       	cpi	r24, 0x01	; 1
     cf8:	81 f4       	brne	.+32     	; 0xd1a <vTaskStartScheduler+0x4c>
     cfa:	f8 94       	cli
     cfc:	8f ef       	ldi	r24, 0xFF	; 255
     cfe:	9f ef       	ldi	r25, 0xFF	; 255
     d00:	90 93 89 04 	sts	0x0489, r25	; 0x800489 <xNextTaskUnblockTime+0x1>
     d04:	80 93 88 04 	sts	0x0488, r24	; 0x800488 <xNextTaskUnblockTime>
     d08:	81 e0       	ldi	r24, 0x01	; 1
     d0a:	80 93 8e 04 	sts	0x048E, r24	; 0x80048e <xSchedulerRunning>
     d0e:	10 92 91 04 	sts	0x0491, r1	; 0x800491 <xTickCount+0x1>
     d12:	10 92 90 04 	sts	0x0490, r1	; 0x800490 <xTickCount>
     d16:	0e 94 03 04 	call	0x806	; 0x806 <xPortStartScheduler>
     d1a:	0f 91       	pop	r16
     d1c:	ff 90       	pop	r15
     d1e:	ef 90       	pop	r14
     d20:	08 95       	ret

00000d22 <vTaskSuspendAll>:
     d22:	80 91 85 04 	lds	r24, 0x0485	; 0x800485 <uxSchedulerSuspended>
     d26:	8f 5f       	subi	r24, 0xFF	; 255
     d28:	80 93 85 04 	sts	0x0485, r24	; 0x800485 <uxSchedulerSuspended>
     d2c:	08 95       	ret

00000d2e <xTaskIncrementTick>:
     d2e:	ef 92       	push	r14
     d30:	ff 92       	push	r15
     d32:	0f 93       	push	r16
     d34:	1f 93       	push	r17
     d36:	cf 93       	push	r28
     d38:	df 93       	push	r29
     d3a:	80 91 85 04 	lds	r24, 0x0485	; 0x800485 <uxSchedulerSuspended>
     d3e:	81 11       	cpse	r24, r1
     d40:	73 c0       	rjmp	.+230    	; 0xe28 <xTaskIncrementTick+0xfa>
     d42:	e0 90 90 04 	lds	r14, 0x0490	; 0x800490 <xTickCount>
     d46:	f0 90 91 04 	lds	r15, 0x0491	; 0x800491 <xTickCount+0x1>
     d4a:	8f ef       	ldi	r24, 0xFF	; 255
     d4c:	e8 1a       	sub	r14, r24
     d4e:	f8 0a       	sbc	r15, r24
     d50:	f0 92 91 04 	sts	0x0491, r15	; 0x800491 <xTickCount+0x1>
     d54:	e0 92 90 04 	sts	0x0490, r14	; 0x800490 <xTickCount>
     d58:	e1 14       	cp	r14, r1
     d5a:	f1 04       	cpc	r15, r1
     d5c:	b9 f4       	brne	.+46     	; 0xd8c <xTaskIncrementTick+0x5e>
     d5e:	80 91 a8 04 	lds	r24, 0x04A8	; 0x8004a8 <pxDelayedTaskList>
     d62:	90 91 a9 04 	lds	r25, 0x04A9	; 0x8004a9 <pxDelayedTaskList+0x1>
     d66:	20 91 a6 04 	lds	r18, 0x04A6	; 0x8004a6 <pxOverflowDelayedTaskList>
     d6a:	30 91 a7 04 	lds	r19, 0x04A7	; 0x8004a7 <pxOverflowDelayedTaskList+0x1>
     d6e:	30 93 a9 04 	sts	0x04A9, r19	; 0x8004a9 <pxDelayedTaskList+0x1>
     d72:	20 93 a8 04 	sts	0x04A8, r18	; 0x8004a8 <pxDelayedTaskList>
     d76:	90 93 a7 04 	sts	0x04A7, r25	; 0x8004a7 <pxOverflowDelayedTaskList+0x1>
     d7a:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <pxOverflowDelayedTaskList>
     d7e:	80 91 8b 04 	lds	r24, 0x048B	; 0x80048b <xNumOfOverflows>
     d82:	8f 5f       	subi	r24, 0xFF	; 255
     d84:	80 93 8b 04 	sts	0x048B, r24	; 0x80048b <xNumOfOverflows>
     d88:	0e 94 af 04 	call	0x95e	; 0x95e <prvResetNextTaskUnblockTime>
     d8c:	80 91 88 04 	lds	r24, 0x0488	; 0x800488 <xNextTaskUnblockTime>
     d90:	90 91 89 04 	lds	r25, 0x0489	; 0x800489 <xNextTaskUnblockTime+0x1>
     d94:	e8 16       	cp	r14, r24
     d96:	f9 06       	cpc	r15, r25
     d98:	08 f4       	brcc	.+2      	; 0xd9c <xTaskIncrementTick+0x6e>
     d9a:	4b c0       	rjmp	.+150    	; 0xe32 <xTaskIncrementTick+0x104>
     d9c:	e0 91 a8 04 	lds	r30, 0x04A8	; 0x8004a8 <pxDelayedTaskList>
     da0:	f0 91 a9 04 	lds	r31, 0x04A9	; 0x8004a9 <pxDelayedTaskList+0x1>
     da4:	80 81       	ld	r24, Z
     da6:	81 11       	cpse	r24, r1
     da8:	07 c0       	rjmp	.+14     	; 0xdb8 <xTaskIncrementTick+0x8a>
     daa:	8f ef       	ldi	r24, 0xFF	; 255
     dac:	9f ef       	ldi	r25, 0xFF	; 255
     dae:	90 93 89 04 	sts	0x0489, r25	; 0x800489 <xNextTaskUnblockTime+0x1>
     db2:	80 93 88 04 	sts	0x0488, r24	; 0x800488 <xNextTaskUnblockTime>
     db6:	3d c0       	rjmp	.+122    	; 0xe32 <xTaskIncrementTick+0x104>
     db8:	e0 91 a8 04 	lds	r30, 0x04A8	; 0x8004a8 <pxDelayedTaskList>
     dbc:	f0 91 a9 04 	lds	r31, 0x04A9	; 0x8004a9 <pxDelayedTaskList+0x1>
     dc0:	05 80       	ldd	r0, Z+5	; 0x05
     dc2:	f6 81       	ldd	r31, Z+6	; 0x06
     dc4:	e0 2d       	mov	r30, r0
     dc6:	c6 81       	ldd	r28, Z+6	; 0x06
     dc8:	d7 81       	ldd	r29, Z+7	; 0x07
     dca:	8a 81       	ldd	r24, Y+2	; 0x02
     dcc:	9b 81       	ldd	r25, Y+3	; 0x03
     dce:	e8 16       	cp	r14, r24
     dd0:	f9 06       	cpc	r15, r25
     dd2:	28 f4       	brcc	.+10     	; 0xdde <xTaskIncrementTick+0xb0>
     dd4:	90 93 89 04 	sts	0x0489, r25	; 0x800489 <xNextTaskUnblockTime+0x1>
     dd8:	80 93 88 04 	sts	0x0488, r24	; 0x800488 <xNextTaskUnblockTime>
     ddc:	2a c0       	rjmp	.+84     	; 0xe32 <xTaskIncrementTick+0x104>
     dde:	8e 01       	movw	r16, r28
     de0:	0e 5f       	subi	r16, 0xFE	; 254
     de2:	1f 4f       	sbci	r17, 0xFF	; 255
     de4:	c8 01       	movw	r24, r16
     de6:	0e 94 01 03 	call	0x602	; 0x602 <uxListRemove>
     dea:	8c 89       	ldd	r24, Y+20	; 0x14
     dec:	9d 89       	ldd	r25, Y+21	; 0x15
     dee:	89 2b       	or	r24, r25
     df0:	21 f0       	breq	.+8      	; 0xdfa <xTaskIncrementTick+0xcc>
     df2:	ce 01       	movw	r24, r28
     df4:	0c 96       	adiw	r24, 0x0c	; 12
     df6:	0e 94 01 03 	call	0x602	; 0x602 <uxListRemove>
     dfa:	8e 89       	ldd	r24, Y+22	; 0x16
     dfc:	90 91 8f 04 	lds	r25, 0x048F	; 0x80048f <uxTopReadyPriority>
     e00:	98 17       	cp	r25, r24
     e02:	10 f4       	brcc	.+4      	; 0xe08 <xTaskIncrementTick+0xda>
     e04:	80 93 8f 04 	sts	0x048F, r24	; 0x80048f <uxTopReadyPriority>
     e08:	90 e0       	ldi	r25, 0x00	; 0
     e0a:	9c 01       	movw	r18, r24
     e0c:	22 0f       	add	r18, r18
     e0e:	33 1f       	adc	r19, r19
     e10:	22 0f       	add	r18, r18
     e12:	33 1f       	adc	r19, r19
     e14:	22 0f       	add	r18, r18
     e16:	33 1f       	adc	r19, r19
     e18:	82 0f       	add	r24, r18
     e1a:	93 1f       	adc	r25, r19
     e1c:	b8 01       	movw	r22, r16
     e1e:	84 54       	subi	r24, 0x44	; 68
     e20:	9b 4f       	sbci	r25, 0xFB	; 251
     e22:	0e 94 af 02 	call	0x55e	; 0x55e <vListInsertEnd>
     e26:	ba cf       	rjmp	.-140    	; 0xd9c <xTaskIncrementTick+0x6e>
     e28:	80 91 8d 04 	lds	r24, 0x048D	; 0x80048d <uxPendedTicks>
     e2c:	8f 5f       	subi	r24, 0xFF	; 255
     e2e:	80 93 8d 04 	sts	0x048D, r24	; 0x80048d <uxPendedTicks>
     e32:	80 e0       	ldi	r24, 0x00	; 0
     e34:	df 91       	pop	r29
     e36:	cf 91       	pop	r28
     e38:	1f 91       	pop	r17
     e3a:	0f 91       	pop	r16
     e3c:	ff 90       	pop	r15
     e3e:	ef 90       	pop	r14
     e40:	08 95       	ret

00000e42 <xTaskResumeAll>:
     e42:	0f 93       	push	r16
     e44:	1f 93       	push	r17
     e46:	cf 93       	push	r28
     e48:	df 93       	push	r29
     e4a:	0f b6       	in	r0, 0x3f	; 63
     e4c:	f8 94       	cli
     e4e:	0f 92       	push	r0
     e50:	80 91 85 04 	lds	r24, 0x0485	; 0x800485 <uxSchedulerSuspended>
     e54:	81 50       	subi	r24, 0x01	; 1
     e56:	80 93 85 04 	sts	0x0485, r24	; 0x800485 <uxSchedulerSuspended>
     e5a:	80 91 85 04 	lds	r24, 0x0485	; 0x800485 <uxSchedulerSuspended>
     e5e:	81 11       	cpse	r24, r1
     e60:	52 c0       	rjmp	.+164    	; 0xf06 <xTaskResumeAll+0xc4>
     e62:	80 91 92 04 	lds	r24, 0x0492	; 0x800492 <uxCurrentNumberOfTasks>
     e66:	81 11       	cpse	r24, r1
     e68:	33 c0       	rjmp	.+102    	; 0xed0 <xTaskResumeAll+0x8e>
     e6a:	4d c0       	rjmp	.+154    	; 0xf06 <xTaskResumeAll+0xc4>
     e6c:	e0 91 a2 04 	lds	r30, 0x04A2	; 0x8004a2 <xPendingReadyList+0x5>
     e70:	f0 91 a3 04 	lds	r31, 0x04A3	; 0x8004a3 <xPendingReadyList+0x6>
     e74:	c6 81       	ldd	r28, Z+6	; 0x06
     e76:	d7 81       	ldd	r29, Z+7	; 0x07
     e78:	ce 01       	movw	r24, r28
     e7a:	0c 96       	adiw	r24, 0x0c	; 12
     e7c:	0e 94 01 03 	call	0x602	; 0x602 <uxListRemove>
     e80:	8e 01       	movw	r16, r28
     e82:	0e 5f       	subi	r16, 0xFE	; 254
     e84:	1f 4f       	sbci	r17, 0xFF	; 255
     e86:	c8 01       	movw	r24, r16
     e88:	0e 94 01 03 	call	0x602	; 0x602 <uxListRemove>
     e8c:	8e 89       	ldd	r24, Y+22	; 0x16
     e8e:	90 91 8f 04 	lds	r25, 0x048F	; 0x80048f <uxTopReadyPriority>
     e92:	98 17       	cp	r25, r24
     e94:	10 f4       	brcc	.+4      	; 0xe9a <xTaskResumeAll+0x58>
     e96:	80 93 8f 04 	sts	0x048F, r24	; 0x80048f <uxTopReadyPriority>
     e9a:	90 e0       	ldi	r25, 0x00	; 0
     e9c:	9c 01       	movw	r18, r24
     e9e:	22 0f       	add	r18, r18
     ea0:	33 1f       	adc	r19, r19
     ea2:	22 0f       	add	r18, r18
     ea4:	33 1f       	adc	r19, r19
     ea6:	22 0f       	add	r18, r18
     ea8:	33 1f       	adc	r19, r19
     eaa:	82 0f       	add	r24, r18
     eac:	93 1f       	adc	r25, r19
     eae:	b8 01       	movw	r22, r16
     eb0:	84 54       	subi	r24, 0x44	; 68
     eb2:	9b 4f       	sbci	r25, 0xFB	; 251
     eb4:	0e 94 af 02 	call	0x55e	; 0x55e <vListInsertEnd>
     eb8:	9e 89       	ldd	r25, Y+22	; 0x16
     eba:	e0 91 0d 05 	lds	r30, 0x050D	; 0x80050d <pxCurrentTCB>
     ebe:	f0 91 0e 05 	lds	r31, 0x050E	; 0x80050e <pxCurrentTCB+0x1>
     ec2:	86 89       	ldd	r24, Z+22	; 0x16
     ec4:	98 17       	cp	r25, r24
     ec6:	30 f0       	brcs	.+12     	; 0xed4 <xTaskResumeAll+0x92>
     ec8:	81 e0       	ldi	r24, 0x01	; 1
     eca:	80 93 8c 04 	sts	0x048C, r24	; 0x80048c <xYieldPending>
     ece:	02 c0       	rjmp	.+4      	; 0xed4 <xTaskResumeAll+0x92>
     ed0:	c0 e0       	ldi	r28, 0x00	; 0
     ed2:	d0 e0       	ldi	r29, 0x00	; 0
     ed4:	80 91 9d 04 	lds	r24, 0x049D	; 0x80049d <xPendingReadyList>
     ed8:	81 11       	cpse	r24, r1
     eda:	c8 cf       	rjmp	.-112    	; 0xe6c <xTaskResumeAll+0x2a>
     edc:	cd 2b       	or	r28, r29
     ede:	11 f0       	breq	.+4      	; 0xee4 <xTaskResumeAll+0xa2>
     ee0:	0e 94 af 04 	call	0x95e	; 0x95e <prvResetNextTaskUnblockTime>
     ee4:	c0 91 8d 04 	lds	r28, 0x048D	; 0x80048d <uxPendedTicks>
     ee8:	cc 23       	and	r28, r28
     eea:	59 f0       	breq	.+22     	; 0xf02 <xTaskResumeAll+0xc0>
     eec:	0e 94 97 06 	call	0xd2e	; 0xd2e <xTaskIncrementTick>
     ef0:	88 23       	and	r24, r24
     ef2:	19 f0       	breq	.+6      	; 0xefa <xTaskResumeAll+0xb8>
     ef4:	81 e0       	ldi	r24, 0x01	; 1
     ef6:	80 93 8c 04 	sts	0x048C, r24	; 0x80048c <xYieldPending>
     efa:	c1 50       	subi	r28, 0x01	; 1
     efc:	b9 f7       	brne	.-18     	; 0xeec <xTaskResumeAll+0xaa>
     efe:	10 92 8d 04 	sts	0x048D, r1	; 0x80048d <uxPendedTicks>
     f02:	80 91 8c 04 	lds	r24, 0x048C	; 0x80048c <xYieldPending>
     f06:	0f 90       	pop	r0
     f08:	0f be       	out	0x3f, r0	; 63
     f0a:	80 e0       	ldi	r24, 0x00	; 0
     f0c:	df 91       	pop	r29
     f0e:	cf 91       	pop	r28
     f10:	1f 91       	pop	r17
     f12:	0f 91       	pop	r16
     f14:	08 95       	ret

00000f16 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     f16:	cf 93       	push	r28
     f18:	df 93       	push	r29
     f1a:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     f1c:	89 2b       	or	r24, r25
     f1e:	49 f0       	breq	.+18     	; 0xf32 <vTaskDelay+0x1c>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     f20:	0e 94 91 06 	call	0xd22	; 0xd22 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     f24:	60 e0       	ldi	r22, 0x00	; 0
     f26:	ce 01       	movw	r24, r28
     f28:	0e 94 cf 05 	call	0xb9e	; 0xb9e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     f2c:	0e 94 21 07 	call	0xe42	; 0xe42 <xTaskResumeAll>
     f30:	01 c0       	rjmp	.+2      	; 0xf34 <vTaskDelay+0x1e>

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
	BaseType_t xAlreadyYielded = pdFALSE;
     f32:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     f34:	81 11       	cpse	r24, r1
     f36:	02 c0       	rjmp	.+4      	; 0xf3c <vTaskDelay+0x26>
		{
			portYIELD_WITHIN_API();
     f38:	0e 94 32 04 	call	0x864	; 0x864 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     f3c:	df 91       	pop	r29
     f3e:	cf 91       	pop	r28
     f40:	08 95       	ret

00000f42 <prvCheckTasksWaitingTermination>:
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
}
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
     f42:	cf 93       	push	r28
     f44:	df 93       	push	r29
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     f46:	24 c0       	rjmp	.+72     	; 0xf90 <prvCheckTasksWaitingTermination+0x4e>
		{
			vTaskSuspendAll();
     f48:	0e 94 91 06 	call	0xd22	; 0xd22 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     f4c:	c0 91 94 04 	lds	r28, 0x0494	; 0x800494 <xTasksWaitingTermination>
			}
			( void ) xTaskResumeAll();
     f50:	0e 94 21 07 	call	0xe42	; 0xe42 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
     f54:	cc 23       	and	r28, r28
     f56:	e1 f0       	breq	.+56     	; 0xf90 <prvCheckTasksWaitingTermination+0x4e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
     f58:	0f b6       	in	r0, 0x3f	; 63
     f5a:	f8 94       	cli
     f5c:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
     f5e:	e0 91 99 04 	lds	r30, 0x0499	; 0x800499 <xTasksWaitingTermination+0x5>
     f62:	f0 91 9a 04 	lds	r31, 0x049A	; 0x80049a <xTasksWaitingTermination+0x6>
     f66:	c6 81       	ldd	r28, Z+6	; 0x06
     f68:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     f6a:	ce 01       	movw	r24, r28
     f6c:	02 96       	adiw	r24, 0x02	; 2
     f6e:	0e 94 01 03 	call	0x602	; 0x602 <uxListRemove>
					--uxCurrentNumberOfTasks;
     f72:	80 91 92 04 	lds	r24, 0x0492	; 0x800492 <uxCurrentNumberOfTasks>
     f76:	81 50       	subi	r24, 0x01	; 1
     f78:	80 93 92 04 	sts	0x0492, r24	; 0x800492 <uxCurrentNumberOfTasks>
					--uxDeletedTasksWaitingCleanUp;
     f7c:	80 91 93 04 	lds	r24, 0x0493	; 0x800493 <uxDeletedTasksWaitingCleanUp>
     f80:	81 50       	subi	r24, 0x01	; 1
     f82:	80 93 93 04 	sts	0x0493, r24	; 0x800493 <uxDeletedTasksWaitingCleanUp>
				}
				taskEXIT_CRITICAL();
     f86:	0f 90       	pop	r0
     f88:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
     f8a:	ce 01       	movw	r24, r28
     f8c:	0e 94 ce 04 	call	0x99c	; 0x99c <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     f90:	80 91 93 04 	lds	r24, 0x0493	; 0x800493 <uxDeletedTasksWaitingCleanUp>
     f94:	81 11       	cpse	r24, r1
     f96:	d8 cf       	rjmp	.-80     	; 0xf48 <prvCheckTasksWaitingTermination+0x6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
     f98:	df 91       	pop	r29
     f9a:	cf 91       	pop	r28
     f9c:	08 95       	ret

00000f9e <prvIdleTask>:

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
     f9e:	0e 94 a1 07 	call	0xf42	; 0xf42 <prvCheckTasksWaitingTermination>
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
     fa2:	0e 94 32 04 	call	0x864	; 0x864 <vPortYield>
     fa6:	fb cf       	rjmp	.-10     	; 0xf9e <prvIdleTask>

00000fa8 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     fa8:	80 91 85 04 	lds	r24, 0x0485	; 0x800485 <uxSchedulerSuspended>
     fac:	88 23       	and	r24, r24
     fae:	21 f0       	breq	.+8      	; 0xfb8 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     fb0:	81 e0       	ldi	r24, 0x01	; 1
     fb2:	80 93 8c 04 	sts	0x048C, r24	; 0x80048c <xYieldPending>
     fb6:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     fb8:	10 92 8c 04 	sts	0x048C, r1	; 0x80048c <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     fbc:	20 91 8f 04 	lds	r18, 0x048F	; 0x80048f <uxTopReadyPriority>
     fc0:	01 c0       	rjmp	.+2      	; 0xfc4 <vTaskSwitchContext+0x1c>
     fc2:	21 50       	subi	r18, 0x01	; 1
     fc4:	82 2f       	mov	r24, r18
     fc6:	90 e0       	ldi	r25, 0x00	; 0
     fc8:	fc 01       	movw	r30, r24
     fca:	ee 0f       	add	r30, r30
     fcc:	ff 1f       	adc	r31, r31
     fce:	ee 0f       	add	r30, r30
     fd0:	ff 1f       	adc	r31, r31
     fd2:	ee 0f       	add	r30, r30
     fd4:	ff 1f       	adc	r31, r31
     fd6:	e8 0f       	add	r30, r24
     fd8:	f9 1f       	adc	r31, r25
     fda:	e4 54       	subi	r30, 0x44	; 68
     fdc:	fb 4f       	sbci	r31, 0xFB	; 251
     fde:	30 81       	ld	r19, Z
     fe0:	33 23       	and	r19, r19
     fe2:	79 f3       	breq	.-34     	; 0xfc2 <vTaskSwitchContext+0x1a>
     fe4:	ac 01       	movw	r20, r24
     fe6:	44 0f       	add	r20, r20
     fe8:	55 1f       	adc	r21, r21
     fea:	44 0f       	add	r20, r20
     fec:	55 1f       	adc	r21, r21
     fee:	44 0f       	add	r20, r20
     ff0:	55 1f       	adc	r21, r21
     ff2:	48 0f       	add	r20, r24
     ff4:	59 1f       	adc	r21, r25
     ff6:	df 01       	movw	r26, r30
     ff8:	01 80       	ldd	r0, Z+1	; 0x01
     ffa:	f2 81       	ldd	r31, Z+2	; 0x02
     ffc:	e0 2d       	mov	r30, r0
     ffe:	02 80       	ldd	r0, Z+2	; 0x02
    1000:	f3 81       	ldd	r31, Z+3	; 0x03
    1002:	e0 2d       	mov	r30, r0
    1004:	12 96       	adiw	r26, 0x02	; 2
    1006:	fc 93       	st	X, r31
    1008:	ee 93       	st	-X, r30
    100a:	11 97       	sbiw	r26, 0x01	; 1
    100c:	41 54       	subi	r20, 0x41	; 65
    100e:	5b 4f       	sbci	r21, 0xFB	; 251
    1010:	e4 17       	cp	r30, r20
    1012:	f5 07       	cpc	r31, r21
    1014:	29 f4       	brne	.+10     	; 0x1020 <vTaskSwitchContext+0x78>
    1016:	42 81       	ldd	r20, Z+2	; 0x02
    1018:	53 81       	ldd	r21, Z+3	; 0x03
    101a:	fd 01       	movw	r30, r26
    101c:	52 83       	std	Z+2, r21	; 0x02
    101e:	41 83       	std	Z+1, r20	; 0x01
    1020:	fc 01       	movw	r30, r24
    1022:	ee 0f       	add	r30, r30
    1024:	ff 1f       	adc	r31, r31
    1026:	ee 0f       	add	r30, r30
    1028:	ff 1f       	adc	r31, r31
    102a:	ee 0f       	add	r30, r30
    102c:	ff 1f       	adc	r31, r31
    102e:	8e 0f       	add	r24, r30
    1030:	9f 1f       	adc	r25, r31
    1032:	fc 01       	movw	r30, r24
    1034:	e4 54       	subi	r30, 0x44	; 68
    1036:	fb 4f       	sbci	r31, 0xFB	; 251
    1038:	01 80       	ldd	r0, Z+1	; 0x01
    103a:	f2 81       	ldd	r31, Z+2	; 0x02
    103c:	e0 2d       	mov	r30, r0
    103e:	86 81       	ldd	r24, Z+6	; 0x06
    1040:	97 81       	ldd	r25, Z+7	; 0x07
    1042:	90 93 0e 05 	sts	0x050E, r25	; 0x80050e <pxCurrentTCB+0x1>
    1046:	80 93 0d 05 	sts	0x050D, r24	; 0x80050d <pxCurrentTCB>
    104a:	20 93 8f 04 	sts	0x048F, r18	; 0x80048f <uxTopReadyPriority>
    104e:	08 95       	ret

00001050 <__umulhisi3>:
    1050:	a2 9f       	mul	r26, r18
    1052:	b0 01       	movw	r22, r0
    1054:	b3 9f       	mul	r27, r19
    1056:	c0 01       	movw	r24, r0
    1058:	a3 9f       	mul	r26, r19
    105a:	70 0d       	add	r23, r0
    105c:	81 1d       	adc	r24, r1
    105e:	11 24       	eor	r1, r1
    1060:	91 1d       	adc	r25, r1
    1062:	b2 9f       	mul	r27, r18
    1064:	70 0d       	add	r23, r0
    1066:	81 1d       	adc	r24, r1
    1068:	11 24       	eor	r1, r1
    106a:	91 1d       	adc	r25, r1
    106c:	08 95       	ret

0000106e <_exit>:
    106e:	f8 94       	cli

00001070 <__stop_program>:
    1070:	ff cf       	rjmp	.-2      	; 0x1070 <__stop_program>
